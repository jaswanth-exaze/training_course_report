# Access Token Expiry Flow (Basic and Exact)

This document explains exactly what happens in this project when access token expires.

---

## 1. One-Line Flow

Expired access token -> protected API returns `401` -> frontend calls `/auth/refresh` with cookie -> if refresh success, retry original request -> else redirect login.

---

## 2. Where `401` Comes From

File: `backend/src/middlewares/auth.middleware.js`

```js
jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {
  if (err) {
    if (err.name === "TokenExpiredError") {
      return res.status(401).json({
        message: "Session expired. Please log in again.",
      });
    }

    return res.status(401).json({
      message: "Invalid token. Please log in again.",
    });
  }

  req.user = decoded;
  next();
});
```

So expiry response is generated by auth middleware itself.

---

## 3. Frontend Behavior on `401`

File: `frontend/js/auth.js`

Frontend wraps `window.fetch` globally. For API calls it:

- attaches bearer token,
- attaches `credentials: "include"`,
- checks if response is `401`.

Main decision code:

```js
if (!apiCall || response.status !== 401 || authCall) {
  return response;
}
```

If it is non-auth API + 401, frontend tries refresh.

---

## 4. Refresh Attempt from Frontend

```js
const refreshRes = await originalFetch(getApiUrl("auth/refresh"), {
  method: "POST",
  credentials: "include",
}).catch(() => null);
```

If refresh returns success and gives new token:

```js
if (refreshRes && refreshRes.ok) {
  const refreshData = await refreshRes.json().catch(() => null);
  if (refreshData && refreshData.token) {
    localStorage.setItem("token", refreshData.token);
    if (refreshData.role) localStorage.setItem("role", refreshData.role);

    const retryOptions = buildRequestOptions(init, true);
    response = await originalFetch(input, retryOptions);
    return response;
  }
}
```

So frontend retries original request one time.

---

## 5. Backend `/auth/refresh` Handling

Route:

```js
// backend/src/routes/auth.routes.js
router.post("/refresh", authController.refreshToken);
```

Controller:

```js
const refreshToken = req.cookies?.[REFRESH_COOKIE_NAME];
if (!refreshToken) {
  return res.status(401).json({ message: "Refresh token missing" });
}

const result = await authService.refreshAccessToken(refreshToken);

res.cookie(REFRESH_COOKIE_NAME, result.refreshToken, getRefreshCookieOptions());
return res.json({
  message: result.message,
  token: result.token,
  role: result.role,
});
```

Refresh token comes from cookie (`req.cookies`) because `cookie-parser` is enabled in `backend/src/app.js`.

---

## 6. Refresh Service Logic (DB + Rotation)

File: `backend/src/services/auth.service.js` -> `refreshAccessToken`

Basic steps:

1. Verify refresh JWT
2. Hash refresh token
3. Start DB transaction
4. Find active refresh row in DB
5. Check expiry
6. Create new access token
7. Create new refresh token
8. Revoke old DB row
9. Insert new DB row
10. Commit and return

Core code:

```js
const [tokenRows] = await connection.query(
  `
  SELECT id, expires_at
  FROM refresh_tokens
  WHERE token = ? AND user_id = ? AND is_revoked = false
  LIMIT 1
  FOR UPDATE
  `,
  [hashedIncomingToken, decoded.user_id],
);

await connection.query(
  `UPDATE refresh_tokens SET is_revoked = true WHERE id = ?`,
  [tokenRecord.id],
);

await connection.query(
  `
  INSERT INTO refresh_tokens (user_id, token, expires_at, is_revoked, created_at)
  VALUES (?, ?, ?, false, NOW())
  `,
  [user.user_id, hashedNextRefreshToken, refreshExpiryDate()],
);
```

---

## 7. If Refresh Fails

If refresh token is missing/invalid/expired/revoked:

- backend `/auth/refresh` returns `401`
- frontend redirects to login

Frontend code:

```js
const message = await getErrorMessage(response);
redirectToLogin(message);
return response;
```

`redirectToLogin` does:

1. store one-time message,
2. clear `token` and `role`,
3. go to `/login.html`.

---

## 8. Request-Response Map

1. Protected API with expired access token

- Response: `401 Session expired...`
- Frontend action: call `/auth/refresh`

2. `/auth/refresh` success

- Response: `200 { token, role }`
- Frontend action: save token and retry original API

3. `/auth/refresh` failure

- Response: `401`
- Frontend action: clear auth and redirect login

---

## 9. Sequence Diagram

```text
Dashboard API call (expired access token)
   -> backend verifyToken
   -> 401 "Session expired"
   -> frontend auth.js catches 401
   -> POST /auth/refresh (cookie)
      -> backend verifies refresh token + DB row
      -> rotates refresh token
      -> returns new access token
   -> frontend stores new token
   -> frontend retries original API
   -> success response to page code
```

Failure branch:

```text
POST /auth/refresh -> 401
frontend clears auth state -> redirect /login.html
```

---

## 10. Most Important Debug Files

- `backend/src/middlewares/auth.middleware.js`
- `backend/src/controllers/auth.controller.js`
- `backend/src/services/auth.service.js`
- `frontend/js/auth.js`
- `backend/src/routes/auth.routes.js`
