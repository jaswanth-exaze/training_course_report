üê≥ What is Docker?
Docker is a tool that lets you package your application and all its dependencies (like libraries, environment variables, configuration files) into a single unit called a container.

Think of it as:
üëâ A lightweight, portable box that contains everything your app needs to run ‚Äî anywhere.

üí° The Problem Before Docker
Before Docker, developers faced a big issue:

‚ÄúIt works on my machine üòÖ ‚Ä¶ but not on yours!‚Äù

Why?
Because your app may work fine on your laptop, but when you move it to another machine (like a production server), something may break:

Different OS versions

Missing libraries or dependencies

Conflicting software versions (e.g., Python 3.8 vs 3.11)

‚úÖ Docker‚Äôs Solution
Docker solves this by packaging your app with all dependencies inside a container.

So, no matter where you run it ‚Äî your laptop, a cloud server, or another computer ‚Äî
the app will behave exactly the same.

üß± Key Concepts in Docker
1. Image
An image is like a blueprint of your application.

It contains everything needed to run your app (OS, code, dependencies, etc.)

Example: python:3.10 is an official Docker image for Python.

2. Container
A container is a running instance of an image.

You can create, start, stop, or delete containers.

Example: You can run 5 containers from the same image.

üì¶ Image = Recipe
üç≤ Container = Dish prepared from the recipe

üß† How Docker Works (in simple words)
You write a Dockerfile (the recipe).

You build it to create an image.

docker build -t myapp .
You run the container from that image.

docker run myapp
Your app runs isolated in its own environment ‚Äî no conflicts!

‚öôÔ∏è Example in Real Life
Imagine you‚Äôre developing a web app using:

Python 3.10

Flask

PostgreSQL

Instead of installing all of that on your system, you can:

Use a Python Docker image for Flask.

Use a PostgreSQL image for the database.

Connect them using Docker Compose (a tool for running multiple containers together).

üß© Benefits of Docker
Benefit	Description
Portability	Run anywhere ‚Äî laptop, server, or cloud
Consistency	Same behavior across environments
Lightweight	Containers share the OS kernel, making them faster than VMs
Isolation	Each app runs in its own container
Scalability	Easily deploy multiple instances

üöÄ Quick Example
Let‚Äôs say you want to run a simple Python script using Docker.

Step 1: Create app.py
  print("Hello from Docker!")
Step 2: Create Dockerfile
  FROM python:3.10
  COPY app.py /app.py
  CMD ["python", "/app.py"]
Step 3: Build the image
  docker build -t hello-docker .
Step 4: Run the container
  docker run hello-docker
üí• Output:
  Hello from Docker!
we just ran our Python app inside a container

====================================================================
CI/CD FLOW WITH DOCKER ‚Äî STEP-BY-STEP EXPLANATION
====================================================================
1Ô∏è‚É£ CONTINUOUS INTEGRATION (CI)
üéØ GOAL:
Automatically test and integrate new code changes into a shared repository.

üîÅ WHAT HAPPENS:

1. Developer writes code and pushes it to GitHub or GitLab.
2. A CI tool (like Jenkins, GitHub Actions, or GitLab CI) detects the push.
3. It automatically:
  ‚Ä¢ Clones the repository
  ‚Ä¢ Builds the project
  ‚Ä¢ Runs automated tests (unit, integration, linting)
  ‚Ä¢ Generates a pass/fail report

üê≥ WHERE DOCKER COMES IN:
Docker creates a consistent build and test environment.
Instead of manually installing dependencies on the CI server, the CI tool spins up a Docker container and performs all builds and tests inside it.

üíª EXAMPLE (GitHub Actions):
jobs:
test:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v4
- name: Run tests inside Docker
run: |
docker build -t myapp-test .
docker run myapp-test pytest
üí° WHY DOCKER IS USEFUL HERE:
‚úî Avoids manual setup on the CI server
‚úî Tests always run in the same environment
‚úî Builds are faster, reproducible, and portable

====================================================================
2Ô∏è‚É£ CONTINUOUS DELIVERY (CD)
üéØ GOAL:
Prepare the tested code for release in a deployable format.

üîÅ WHAT HAPPENS:

1. After CI passes, the CD pipeline builds a deployable artifact (usually a Docker image).
2. That image is pushed to a container registry such as Docker Hub, AWS ECR, or Google GCR.
3. Optional steps include:
  ‚Ä¢ Security scanning
  ‚Ä¢ Integration testing
  ‚Ä¢ Manual approval before release

üê≥ WHERE DOCKER COMES IN:
The artifact being delivered is the Docker image itself.
Docker builds a versioned, standardized package containing code and dependencies.

üíª EXAMPLE COMMANDS:
docker build -t myapp:latest .
docker push myusername/myapp:latest
üí° WHY DOCKER IS ESSENTIAL HERE:
‚úî The same image is used for testing, staging, and production
‚úî No environment mismatch
‚úî ‚ÄúIf it runs in the container, it runs anywhere‚Äù

====================================================================
3Ô∏è‚É£ CONTINUOUS DEPLOYMENT
üéØ GOAL:
Automatically release every tested and approved build to production.

üîÅ WHAT HAPPENS:

1. The latest Docker image is pulled from the container registry.
2. A deployment tool (like Kubernetes, Docker Swarm, or AWS ECS) runs it on production servers.
3. Load balancers or rolling updates ensure smooth, zero-downtime releases.

üíª EXAMPLE (Kubernetes Deployment):
apiVersion: apps/v1
kind: Deployment
metadata:
name: myapp
spec:
replicas: 3
template:
spec:
containers:
- name: myapp
image: myusername/myapp:latest
ports:
- containerPort: 8080
üí° WHY DOCKER IS CRITICAL HERE:
‚úî Same tested image runs in production
‚úî Easy rollback using older images
‚úî Integrates seamlessly with orchestration tools (like Kubernetes)

====================================================================
üß© SUMMARY ‚Äî WHERE DOCKER IS USED AND WHY
STAGE	           DOCKER‚ÄôS ROLE	                                WHY IT‚ÄôS USEFUL
Continuous         Integration Runs builds/tests inside containers	Avoids ‚Äúworks on my machine‚Äù issues
Continuous         Delivery Packages app into Docker image	        Ensures consistency between environments
Deployment	       Runs containers in production	                Enables easy scaling, rollback, portability
====================================================================
üí° REAL-WORLD EXAMPLE
WITHOUT DOCKER:
‚Ä¢ Developers manually install dependencies.
‚Ä¢ The app may behave differently in production.
‚Ä¢ Deployments are slow and risky.

WITH DOCKER:
‚Ä¢ Everything is defined in a Dockerfile (Python version, dependencies, ports).
‚Ä¢ The same image runs in dev, test, and production.
‚Ä¢ CI/CD pipelines automate the full process (build ‚Üí test ‚Üí deploy).

====================================================================
üìú SIMPLIFIED FLOW (TEXT VIEW)
1Ô∏è‚É£ Developer pushes code to repository
‚¨áÔ∏è
2Ô∏è‚É£ CI: Build + Test (runs inside Docker container)
‚¨áÔ∏è
3Ô∏è‚É£ CD: Build Docker image ‚Üí Push to registry
‚¨áÔ∏è
4Ô∏è‚É£ Deployment: Pull image ‚Üí Run container in production

====================================================================
üîë KEY TAKEAWAYS
‚úî Docker provides:
‚Ä¢ Environment consistency across all machines
‚Ä¢ Fast and automated deployments
‚Ä¢ Portability across operating systems and clouds
‚Ä¢ Scalability with orchestration tools (like Kubernetes)

üí¨ In short:
Docker is the engine that powers modern CI/CD ‚Äî making builds reproducible, deployments reliable, and scaling effortless.
==============================
ü™ü DOCKER INSTALLATION ON WINDOWS
üéØ REQUIREMENTS:
‚úî Windows 10 (64-bit) or Windows 11
‚úî WSL 2 (Windows Subsystem for Linux) enabled
‚úî Hardware virtualization enabled in BIOS

STEP 1: ENABLE WSL 2
Open PowerShell as Administrator

Run the following command:

wsl --install
(If WSL is already installed, make sure version 2 is enabled)

wsl --set-default-version 2
Reboot your system after installation.

STEP 2: DOWNLOAD DOCKER DESKTOP
Go to: https://www.docker.com/products/docker-desktop

Download Docker Desktop for Windows.

Run the installer and follow on-screen steps.

‚úÖ During installation:
‚Ä¢ Ensure ‚ÄúUse WSL 2 instead of Hyper-V‚Äù is selected.
‚Ä¢ Keep ‚ÄúAdd shortcut to desktop‚Äù checked (optional).

STEP 3: START DOCKER DESKTOP
After installation, open Docker Desktop.

Wait until the Docker whale üê≥ icon turns stable (running).

You can verify installation with:

docker --version
Example output:

Docker version 27.0.2, build f08183b
STEP 4: TEST DOCKER
Run this command in PowerShell or CMD:

docker run hello-world
‚úÖ If successful, you‚Äôll see:
‚ÄúHello from Docker! This message shows that your installation appears to be working correctly.‚Äù

STEP 5: OPTIONAL SETTINGS
‚Ä¢ To start Docker automatically on boot ‚Üí enable ‚ÄúStart Docker Desktop when you log in‚Äù.
‚Ä¢ To allocate more CPU/RAM ‚Üí go to Docker Desktop ‚Üí Settings ‚Üí Resources.
==============================
üêß DOCKER INSTALLATION ON UBUNTU
üéØ REQUIREMENTS:
‚úî Ubuntu 20.04, 22.04, or newer
‚úî Sudo privileges
‚úî Internet connection

STEP 1: REMOVE OLD VERSIONS
Run these commands:

sudo apt remove docker docker-engine docker.io containerd runc
STEP 2: UPDATE SYSTEM PACKAGES
sudo apt update
sudo apt upgrade -y
STEP 3: INSTALL PREREQUISITE PACKAGES
sudo apt install ca-certificates curl gnupg lsb-release -y
STEP 4: ADD DOCKER‚ÄôS OFFICIAL GPG KEY
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
STEP 5: SET UP THE DOCKER REPOSITORY
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
  https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
STEP 6: INSTALL DOCKER ENGINE
sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y
STEP 7: VERIFY INSTALLATION
Check Docker version:

docker --version
Run test container:

sudo docker run hello-world
‚úÖ You should see:
‚ÄúHello from Docker! Your installation appears to be working correctly.‚Äù
====================================================================================================================
DOCKER IMAGE
====================================================================

A Docker Image is a blueprint or template used to create containers.

An image contains:
	- The application code
	- Required libraries and dependencies
	- System tools and configuration files
	- A base operating system layer (like Ubuntu or Alpine)
Images are read-only and reusable.
They define what your application looks like and how it runs.


EXAMPLE:
The image "python:3.10" includes:
	- A lightweight Linux system
	- Python 3.10 pre-installed
	- Essential Python tools
You can use this image to run Python anywhere, witho
===============================================================
2. DOCKER CONTAINER
===============================================================
A Docker Container is a running instance of an image.

It acts like a mini isolated computer that runs your application.

Each container has:
- Its own filesystem (copied from the image)
- Its own memory and process space
- Isolation from other containers and the host system

You can start, stop, or delete containers anytime.ut installing Python manually.
EXAMPLE:
Command:
docker run python:3.10

What happens:
1. Docker checks for the image "python:3.10".
2. If not found, it downloads it from Docker Hub.
3. It creates a container from that image.
4. Python runs inside that container.

3. RELATIONSHIP BETWEEN IMAGE AND CONTAINER
	Image = Blueprint (read-only)
	Container = Running instance created from the image
			
			Analogy: Image = Recipe, Container = Cooked Dish
	You "run" a container from an image.

4. VISUAL UNDERSTANDING
üß† SIMPLE VISUAL UNDERSTANDING
[ Docker Image ]
       |
       |---> [ Container #1 ]
       |---> [ Container #2 ]
       |---> [ Container #3 ]
---------------------------------------------------------------------------
DOCKER IMAGE TAGS
=================
Docker image tags are used to identify different versions or variants of the same image.

Each image on Docker Hub or your local system can have multiple tags.
A tag is like a label that helps you specify which version of the image you want to use.
A tag is a human-readable identifier attached to a Docker image.
It tells Docker which version or build of the image you are referring to.
Example:
python:3.10
python:3.11
python:latest

Here:
- "python" is the image name.
- "3.10", "3.11", and "latest" are tags.

If you do not specify a tag, Docker automatically uses the tag "latest".
Example:
docker pull ubuntu
is the same as:
docker pull ubuntu:latest

 IMAGE NAMING STRUCTURE
		repository_name : tag
=============================================================================================
5. USEFUL COMMANDS
=============================================================================================
List available images:
	docker images

Remove an image:
	docker rmi <image_id>

Remove all images:
	docker rmi $(docker images)

List running containers:
	docker ps

List all containers (running + stopped):
	docker ps -a

Remove a container:
	docker rm <container_id>
	docker rm <container_name>

Remove all stopped containers
	docker container prune
	docker rm $(docker ps --filter status=exited -q)

		docker ps --filter status=exited Show stopped containers
		docker ps --filter status=exited -q Show only IDs
		docker rm $(docker ps --filter status=exited -q) Remove all stopped containers
		docker container prune Remove stopped containers (asks confirmation)
		docker rm -f $(docker ps -aq) Remove all containers (force)
To forcefully stop and remove a running container:
	docker rm -f <container_name_or_id>
Explanation:
	- "-f" or "--force" stops the container (if running) and deletes it immediately.

To remove every container on your system:
	docker rm -f $(docker ps -aq)
Explanation:
- "docker ps -aq" lists all container IDs.
- "docker rm -f" deletes them all forcefully.
------------------------------------------------------------------------------------------
UBUNTU DOCKER IMAGE
The Ubuntu Docker image is one of the most commonly used base images in Docker.
It provides a lightweight, clean Ubuntu environment inside a container
so you can run Linux commands and build applications easily.

To download the Ubuntu image:
		docker pull ubuntu
You can also pull a specific version:
		docker pull ubuntu:22.04

you can start a container from the Ubuntu image.

Command:
		docker run -it ubuntu

Explanation:
- "run" creates and starts a new container.
- "-it" makes it interactive (you can type commands inside).
- "ubuntu" is the image name.

You will enter a shell prompt inside the container, like:
root@b9a4f22e8b61:/#

This means you are now inside an Ubuntu environment running inside Docker.

To exit the container, type:
		exit
or press:
		Ctrl + D

This stops the container and brings you back to your host terminal.



====================================================================
1. START A STOPPED CONTAINER
Use the "docker start" command followed by the container name or ID.

Example:
docker start myubuntu

This will start the container in the background.

If you want to attach to it (enter the container terminal again):
docker start -ai myubuntu

Options:
-a Attach to the container output.
-i Keep it interactive (allows you to type commands).

====================================================================
2. RESTART A RUNNING CONTAINER
If the container is already running and you want to restart it (stop + start automatically):
docker restart <container_id or name>

Example:
docker restart webserver
docker restart 4585e3995b52

Docker stops the container, waits a few seconds, and then starts it again.

====================================================================
3. STOP AND RESTART MANUALLY
Stop a running container:
docker stop webserver
docker stop 4585e3995b52

====================================================================
EXECUTION OF COMMANDS INSIDE A RUNNING CONTAINER

In Docker, you can execute commands inside a running container
to inspect, troubleshoot, or manage applications without stopping them.

You don‚Äôt need to recreate or restart the container ‚Äî
you can directly access it and run commands just like in a regular Linux shell.


First, identify which containers are currently running.

RUN A COMMAND INSIDE A RUNNING CONTAINER
Use the command:
docker exec [OPTIONS] <container_name_or_id> <command>

This allows you to execute any command inside a running container
without attaching to it permanently.

 BASIC EXAMPLES
Example 1: Check which user is active
docker exec myubuntu whoami

Output:
root

Example 2: List files inside the container‚Äôs root directory
docker exec myubuntu ls /

Example 3: Display environment variables
docker exec myubuntu env

C:\Users\Exaze>docker exec -it dc81f348738f date
Wed Nov 12 10:51:46 UTC 2025

========================================================================================================
VIEWING DOCKER CONTAINER LOGS

Docker provides logging features to help you view and analyze the output (logs)
generated by applications running inside containers.

Logs are essential for debugging, monitoring, and tracking the behavior of containers.

BASIC COMMAND TO VIEW LOGS
Command:
docker logs <container_name_or_id>

Example:
docker logs webserver
Output example:
Starting Nginx server...
Nginx running on port 80
172.17.0.1 - - [12/Nov/2025:10:22:03] "GET /index.html" 200
This command prints all logs from the container since it was created.

VIEW REAL-TIME (LIVE) LOGS
To continuously stream live logs as the container runs, use the "-f" flag.

Command:
docker logs -f <container_name_or_id>

Example:
docker logs -f webserver

Explanation:
- "-f" stands for "follow", similar to "tail -f" in Linux.
- It updates the terminal in real time as new logs are generated.

To stop viewing live logs, press:
Ctrl + C
Example:
docker logs --tail 10 webserver

This displays only the last 10 lines of logs.

To include timestamps in log output:
docker logs --timestamps <container_name_or_id>

Example:
docker logs --timestamps webserver 
Command Description
docker logs <name> View container logs
docker logs -f <name> Stream logs live (follow mode)
docker logs --tail N <name> Show last N log lines
docker logs --timestamps <name> Show logs with timestamps
docker logs -f --tail N <name> Stream last N lines with updates
docker inspect -f ... Check log driver
docker run --log-driver <driver> Use specific log driver

RENAME A DOCKER CONTAINER
The "docker rename" command allows you to change the name of an existing container
without stopping or recreating it.

It‚Äôs useful when you want to give containers meaningful names
(for easier identification and management).
Command format:
docker rename <old_name> <new_name>

Example:
docker rename old_container myubuntu

This changes the container‚Äôs name from "old_container" to "myubuntu".

====================================================================
DOCKER SAVE ‚Äî SAVING DOCKER IMAGES TO A TAR FILE
The docker save command is used to export a Docker image
into a single .tar archive file (tarball).

It is useful when you want to:
- Back up an image.
- Transfer an image to another system without using Docker Hub.
- Store images offline.
BASIC SYNTAX
Command format:
docker save [OPTIONS] -o <file_name>.tar <image_name>:<tag>

Example:
docker save -o ubuntu_backup.tar ubuntu:22.04

Explanation:
- "save" ‚Üí exports the image.
- "-o" ‚Üí specifies the output file.
- "ubuntu_backup.tar" ‚Üí name of the saved file.
- "ubuntu:22.04" ‚Üí the image you want to save

IMPORTING A DOCKER IMAGE FROM A TAR FILE
When you have a Docker image saved as a .tar archive file,
you can import or load it back into Docker using the docker load or docker import commands.

Both commands are used to restore images, but they serve different purposes.

Use the docker load command when the image was created using docker save.

Command syntax:
docker load -i <file_name>.tar

Example:
docker load -i ubuntu_backup.tar

Explanation:
- "load" tells Docker to import an image from a file.
- "-i" specifies the input tar file (the image archive).

SHOW DOCKER CONTAINER STATISTICS
The docker stats command is used to monitor real-time performance
and resource usage of running Docker containers.

It shows live statistics such as:
- CPU usage
- Memory usage
- Network I/O
- Disk I/O
- PIDs (process count)

This helps you understand container performance and detect issues.

Command:
docker stats

This displays a live, continuously updating table of running containers.


+----------------------------+------------------------------------------+
| Action / Category          | Command / Example                         |
+----------------------------+------------------------------------------+
| show version               | docker --version                          |
| show system info           | docker info                               |
+----------------------------+------------------------------------------+
| list images                | docker images                             |
| pull image                 | docker pull ubuntu                        |
| remove image               | docker rmi ubuntu:latest                  |
| build image                | docker build -t myapp:v1 .                |
| tag image                  | docker tag myapp:v1 myapp:latest          |
+----------------------------+------------------------------------------+
| run container              | docker run ubuntu                         |
| run interactive            | docker run -it ubuntu                     |
| run detached               | docker run -d nginx                       |
| run with name              | docker run --name myubuntu ubuntu         |
| list running containers    | docker ps                                 |
| list all containers        | docker ps -a                              |
| start container            | docker start myubuntu                     |
| stop container             | docker stop myubuntu                      |
| restart container          | docker restart myubuntu                   |
| remove container           | docker rm myubuntu                        |
| force remove container     | docker rm -f myubuntu                     |
+----------------------------+------------------------------------------+
| exec command inside        | docker exec myubuntu ls /                |
| exec interactive shell     | docker exec -it myubuntu /bin/bash        |
| attach to container        | docker attach myubuntu                    |
+----------------------------+------------------------------------------+
| view logs                  | docker logs myubuntu                      |
| follow logs live           | docker logs -f myubuntu                   |
| show last 20 log lines     | docker logs --tail 20 myubuntu            |
+----------------------------+------------------------------------------+
| save image to tar          | docker save -o ubuntu.tar ubuntu:latest   |
| load image from tar        | docker load -i ubuntu.tar                 |
| export container fs        | docker export myubuntu > backup.tar       |
| import fs as image         | docker import backup.tar myubuntu:v1      |
+----------------------------+------------------------------------------+
| prune stopped containers   | docker container prune                    |
| prune unused images        | docker image prune                        |
| full cleanup               | docker system prune -a                    |
+----------------------------+------------------------------------------+
| list networks              | docker network ls                         |
| create network             | docker network create mynet               |
| connect to network         | docker network connect mynet myubuntu     |
+----------------------------+------------------------------------------+
| list volumes               | docker volume ls                          |
| create volume              | docker volume create myvol                |
| remove volume              | docker volume rm myvol                    |
+----------------------------+------------------------------------------+
| inspect container          | docker inspect myubuntu                   |
| view processes             | docker top myubuntu                       |
| resource stats             | docker stats                              |
| port mappings              | docker port myubuntu                      |
+----------------------------+------------------------------------------+
| stop all (Linux)           | docker stop $(docker ps -q)               |
| remove all (Linux)         | docker rm -f $(docker ps -aq)             |
| remove all images          | docker rmi -f $(docker images -q)         |
+----------------------------+------------------------------------------+
| remove all (Win PS)        | docker rm -f (docker ps -aq)              |
+----------------------------+------------------------------------------+

DOCKER RUN OPTIONS
+------------------------------+------------------------------------------+------------------------------------------+
| docker run Option            | Example                                  | Description                              |
+------------------------------+------------------------------------------+------------------------------------------+
| --name                       | docker run --name myapp ubuntu           | Assign a custom container name           |
| -d                           | docker run -d nginx                      | Run in background (detached mode)        |
| -it                          | docker run -it ubuntu /bin/bash          | Interactive terminal shell               |
| --rm                         | docker run --rm ubuntu                   | Remove container after exit              |
| -p                           | docker run -p 8080:80 nginx              | Map host port to container port          |
| -P                           | docker run -P nginx                      | Map all exposed ports to random ports    |
+------------------------------+------------------------------------------+------------------------------------------+
| -v                           | docker run -v myvol:/data ubuntu         | Mount a Docker volume                    |
| -v (bind mount)              | docker run -v C:\app:/app ubuntu         | Mount host folder inside container       |
| --mount                      | docker run --mount type=bind,...         | Advanced mount with full control         |
+------------------------------+------------------------------------------+------------------------------------------+
| -e                           | docker run -e MODE=prod myapp            | Set environment variable                 |
| --env-file                   | docker run --env-file config.env myapp   | Load env variables from file             |
+------------------------------+------------------------------------------+------------------------------------------+
| --network                    | docker run --network mynet ubuntu        | Attach container to a network            |
| --hostname                   | docker run --hostname app1 ubuntu        | Set container hostname                   |
| --ip                         | docker run --network mynet --ip ...      | Assign static IP in user network         |
+------------------------------+------------------------------------------+------------------------------------------+
| --restart always             | docker run --restart always myapp        | Always restart container on failure      |
| --restart unless-stopped     | docker run --restart unless-stopped app  | Restart unless manually stopped          |
| --restart on-failure         | docker run --restart on-failure app      | Restart only if exit code != 0           |
+------------------------------+------------------------------------------+------------------------------------------+
| --memory                     | docker run --memory 512m myapp           | Limit container RAM                      |
| --cpus                       | docker run --cpus 1.5 myapp              | Limit CPU usage                          |
| --cpu-shares                | docker run --cpu-shares 512 myapp        | Set CPU priority                         |
| --memory-swap                | docker run --memory 512m --memory-swap 1g| Limit RAM + Swap                         |
+------------------------------+------------------------------------------+------------------------------------------+
| --privileged                 | docker run --privileged ubuntu           | Full host access (dangerous)             |
| --user                       | docker run --user 1000:1000 ubuntu       | Run container as specific user           |
| --cap-add                    | docker run --cap-add NET_ADMIN ubuntu    | Add extra Linux capabilities             |
+------------------------------+------------------------------------------+------------------------------------------+
| --workdir                    | docker run --workdir /app ubuntu         | Set working directory inside container   |
| --entrypoint                 | docker run --entrypoint /bin/sh ubuntu   | Override container entrypoint            |
| CMD override                 | docker run ubuntu echo ‚Äúhello‚Äù           | Replace default CMD command              |
+------------------------------+------------------------------------------+------------------------------------------+
| --detach-keys                | docker run --detach-keys="ctrl-x" ubuntu | Change detach key combination            |
| --log-driver                 | docker run --log-driver json-file ubuntu | Select container logging mechanism       |
| --dns                        | docker run --dns 8.8.8.8 ubuntu          | Use custom DNS server                    |
+------------------------------+------------------------------------------+------------------------------------------+
