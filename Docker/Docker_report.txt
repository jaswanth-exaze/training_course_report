ðŸ³ What is Docker?
Docker is a tool that lets you package your application and all its dependencies (like libraries, environment variables, configuration files) into a single unit called a container.

Think of it as:
ðŸ‘‰ A lightweight, portable box that contains everything your app needs to run â€” anywhere.

ðŸ’¡ The Problem Before Docker
Before Docker, developers faced a big issue:

â€œIt works on my machine ðŸ˜… â€¦ but not on yours!â€

Why?
Because your app may work fine on your laptop, but when you move it to another machine (like a production server), something may break:

Different OS versions

Missing libraries or dependencies

Conflicting software versions (e.g., Python 3.8 vs 3.11)

âœ… Dockerâ€™s Solution
Docker solves this by packaging your app with all dependencies inside a container.

So, no matter where you run it â€” your laptop, a cloud server, or another computer â€”
the app will behave exactly the same.

ðŸ§± Key Concepts in Docker
1. Image
An image is like a blueprint of your application.

It contains everything needed to run your app (OS, code, dependencies, etc.)

Example: python:3.10 is an official Docker image for Python.

2. Container
A container is a running instance of an image.

You can create, start, stop, or delete containers.

Example: You can run 5 containers from the same image.

ðŸ“¦ Image = Recipe
ðŸ² Container = Dish prepared from the recipe

ðŸ§  How Docker Works (in simple words)
You write a Dockerfile (the recipe).

You build it to create an image.

docker build -t myapp .
You run the container from that image.

docker run myapp
Your app runs isolated in its own environment â€” no conflicts!

âš™ï¸ Example in Real Life
Imagine youâ€™re developing a web app using:

Python 3.10

Flask

PostgreSQL

Instead of installing all of that on your system, you can:

Use a Python Docker image for Flask.

Use a PostgreSQL image for the database.

Connect them using Docker Compose (a tool for running multiple containers together).

ðŸ§© Benefits of Docker
Benefit	Description
Portability	Run anywhere â€” laptop, server, or cloud
Consistency	Same behavior across environments
Lightweight	Containers share the OS kernel, making them faster than VMs
Isolation	Each app runs in its own container
Scalability	Easily deploy multiple instances

ðŸš€ Quick Example
Letâ€™s say you want to run a simple Python script using Docker.

Step 1: Create app.py
  print("Hello from Docker!")
Step 2: Create Dockerfile
  FROM python:3.10
  COPY app.py /app.py
  CMD ["python", "/app.py"]
Step 3: Build the image
  docker build -t hello-docker .
Step 4: Run the container
  docker run hello-docker
ðŸ’¥ Output:
  Hello from Docker!
we just ran our Python app inside a container

====================================================================
CI/CD FLOW WITH DOCKER â€” STEP-BY-STEP EXPLANATION
====================================================================
1ï¸âƒ£ CONTINUOUS INTEGRATION (CI)
ðŸŽ¯ GOAL:
Automatically test and integrate new code changes into a shared repository.

ðŸ” WHAT HAPPENS:

1. Developer writes code and pushes it to GitHub or GitLab.
2. A CI tool (like Jenkins, GitHub Actions, or GitLab CI) detects the push.
3. It automatically:
  â€¢ Clones the repository
  â€¢ Builds the project
  â€¢ Runs automated tests (unit, integration, linting)
  â€¢ Generates a pass/fail report

ðŸ³ WHERE DOCKER COMES IN:
Docker creates a consistent build and test environment.
Instead of manually installing dependencies on the CI server, the CI tool spins up a Docker container and performs all builds and tests inside it.

ðŸ’» EXAMPLE (GitHub Actions):
jobs:
test:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v4
- name: Run tests inside Docker
run: |
docker build -t myapp-test .
docker run myapp-test pytest
ðŸ’¡ WHY DOCKER IS USEFUL HERE:
âœ” Avoids manual setup on the CI server
âœ” Tests always run in the same environment
âœ” Builds are faster, reproducible, and portable

====================================================================
2ï¸âƒ£ CONTINUOUS DELIVERY (CD)
ðŸŽ¯ GOAL:
Prepare the tested code for release in a deployable format.

ðŸ” WHAT HAPPENS:

1. After CI passes, the CD pipeline builds a deployable artifact (usually a Docker image).
2. That image is pushed to a container registry such as Docker Hub, AWS ECR, or Google GCR.
3. Optional steps include:
  â€¢ Security scanning
  â€¢ Integration testing
  â€¢ Manual approval before release

ðŸ³ WHERE DOCKER COMES IN:
The artifact being delivered is the Docker image itself.
Docker builds a versioned, standardized package containing code and dependencies.

ðŸ’» EXAMPLE COMMANDS:
docker build -t myapp:latest .
docker push myusername/myapp:latest
ðŸ’¡ WHY DOCKER IS ESSENTIAL HERE:
âœ” The same image is used for testing, staging, and production
âœ” No environment mismatch
âœ” â€œIf it runs in the container, it runs anywhereâ€

====================================================================
3ï¸âƒ£ CONTINUOUS DEPLOYMENT
ðŸŽ¯ GOAL:
Automatically release every tested and approved build to production.

ðŸ” WHAT HAPPENS:

1. The latest Docker image is pulled from the container registry.
2. A deployment tool (like Kubernetes, Docker Swarm, or AWS ECS) runs it on production servers.
3. Load balancers or rolling updates ensure smooth, zero-downtime releases.

ðŸ’» EXAMPLE (Kubernetes Deployment):
apiVersion: apps/v1
kind: Deployment
metadata:
name: myapp
spec:
replicas: 3
template:
spec:
containers:
- name: myapp
image: myusername/myapp:latest
ports:
- containerPort: 8080
ðŸ’¡ WHY DOCKER IS CRITICAL HERE:
âœ” Same tested image runs in production
âœ” Easy rollback using older images
âœ” Integrates seamlessly with orchestration tools (like Kubernetes)

====================================================================
ðŸ§© SUMMARY â€” WHERE DOCKER IS USED AND WHY
STAGE	           DOCKERâ€™S ROLE	                                WHY ITâ€™S USEFUL
Continuous         Integration Runs builds/tests inside containers	Avoids â€œworks on my machineâ€ issues
Continuous         Delivery Packages app into Docker image	        Ensures consistency between environments
Deployment	       Runs containers in production	                Enables easy scaling, rollback, portability
====================================================================
ðŸ’¡ REAL-WORLD EXAMPLE
WITHOUT DOCKER:
â€¢ Developers manually install dependencies.
â€¢ The app may behave differently in production.
â€¢ Deployments are slow and risky.

WITH DOCKER:
â€¢ Everything is defined in a Dockerfile (Python version, dependencies, ports).
â€¢ The same image runs in dev, test, and production.
â€¢ CI/CD pipelines automate the full process (build â†’ test â†’ deploy).

====================================================================
ðŸ“œ SIMPLIFIED FLOW (TEXT VIEW)
1ï¸âƒ£ Developer pushes code to repository
â¬‡ï¸
2ï¸âƒ£ CI: Build + Test (runs inside Docker container)
â¬‡ï¸
3ï¸âƒ£ CD: Build Docker image â†’ Push to registry
â¬‡ï¸
4ï¸âƒ£ Deployment: Pull image â†’ Run container in production

====================================================================
ðŸ”‘ KEY TAKEAWAYS
âœ” Docker provides:
â€¢ Environment consistency across all machines
â€¢ Fast and automated deployments
â€¢ Portability across operating systems and clouds
â€¢ Scalability with orchestration tools (like Kubernetes)

ðŸ’¬ In short:
Docker is the engine that powers modern CI/CD â€” making builds reproducible, deployments reliable, and scaling effortless.
==============================
ðŸªŸ DOCKER INSTALLATION ON WINDOWS
ðŸŽ¯ REQUIREMENTS:
âœ” Windows 10 (64-bit) or Windows 11
âœ” WSL 2 (Windows Subsystem for Linux) enabled
âœ” Hardware virtualization enabled in BIOS

STEP 1: ENABLE WSL 2
Open PowerShell as Administrator

Run the following command:

wsl --install
(If WSL is already installed, make sure version 2 is enabled)

wsl --set-default-version 2
Reboot your system after installation.

STEP 2: DOWNLOAD DOCKER DESKTOP
Go to: https://www.docker.com/products/docker-desktop

Download Docker Desktop for Windows.

Run the installer and follow on-screen steps.

âœ… During installation:
â€¢ Ensure â€œUse WSL 2 instead of Hyper-Vâ€ is selected.
â€¢ Keep â€œAdd shortcut to desktopâ€ checked (optional).

STEP 3: START DOCKER DESKTOP
After installation, open Docker Desktop.

Wait until the Docker whale ðŸ³ icon turns stable (running).

You can verify installation with:

docker --version
Example output:

Docker version 27.0.2, build f08183b
STEP 4: TEST DOCKER
Run this command in PowerShell or CMD:

docker run hello-world
âœ… If successful, youâ€™ll see:
â€œHello from Docker! This message shows that your installation appears to be working correctly.â€

STEP 5: OPTIONAL SETTINGS
â€¢ To start Docker automatically on boot â†’ enable â€œStart Docker Desktop when you log inâ€.
â€¢ To allocate more CPU/RAM â†’ go to Docker Desktop â†’ Settings â†’ Resources.
==============================
ðŸ§ DOCKER INSTALLATION ON UBUNTU
ðŸŽ¯ REQUIREMENTS:
âœ” Ubuntu 20.04, 22.04, or newer
âœ” Sudo privileges
âœ” Internet connection

STEP 1: REMOVE OLD VERSIONS
Run these commands:

sudo apt remove docker docker-engine docker.io containerd runc
STEP 2: UPDATE SYSTEM PACKAGES
sudo apt update
sudo apt upgrade -y
STEP 3: INSTALL PREREQUISITE PACKAGES
sudo apt install ca-certificates curl gnupg lsb-release -y
STEP 4: ADD DOCKERâ€™S OFFICIAL GPG KEY
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
STEP 5: SET UP THE DOCKER REPOSITORY
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
  https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
STEP 6: INSTALL DOCKER ENGINE
sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y
STEP 7: VERIFY INSTALLATION
Check Docker version:

docker --version
Run test container:

sudo docker run hello-world
âœ… You should see:
â€œHello from Docker! Your installation appears to be working correctly.â€
====================================================================================================================
DOCKER IMAGE
====================================================================

A Docker Image is a blueprint or template used to create containers.

An image contains:
	- The application code
	- Required libraries and dependencies
	- System tools and configuration files
	- A base operating system layer (like Ubuntu or Alpine)
Images are read-only and reusable.
They define what your application looks like and how it runs.


EXAMPLE:
The image "python:3.10" includes:
	- A lightweight Linux system
	- Python 3.10 pre-installed
	- Essential Python tools
You can use this image to run Python anywhere, witho
===============================================================
2. DOCKER CONTAINER
===============================================================
A Docker Container is a running instance of an image.

It acts like a mini isolated computer that runs your application.

Each container has:
- Its own filesystem (copied from the image)
- Its own memory and process space
- Isolation from other containers and the host system

You can start, stop, or delete containers anytime.ut installing Python manually.
EXAMPLE:
Command:
docker run python:3.10

What happens:
1. Docker checks for the image "python:3.10".
2. If not found, it downloads it from Docker Hub.
3. It creates a container from that image.
4. Python runs inside that container.

3. RELATIONSHIP BETWEEN IMAGE AND CONTAINER
	Image = Blueprint (read-only)
	Container = Running instance created from the image
			
			Analogy: Image = Recipe, Container = Cooked Dish
	You "run" a container from an image.

4. VISUAL UNDERSTANDING
ðŸ§  SIMPLE VISUAL UNDERSTANDING
[ Docker Image ]
       |
       |---> [ Container #1 ]
       |---> [ Container #2 ]
       |---> [ Container #3 ]
---------------------------------------------------------------------------
DOCKER IMAGE TAGS
=================
Docker image tags are used to identify different versions or variants of the same image.

Each image on Docker Hub or your local system can have multiple tags.
A tag is like a label that helps you specify which version of the image you want to use.
A tag is a human-readable identifier attached to a Docker image.
It tells Docker which version or build of the image you are referring to.
Example:
python:3.10
python:3.11
python:latest

Here:
- "python" is the image name.
- "3.10", "3.11", and "latest" are tags.

If you do not specify a tag, Docker automatically uses the tag "latest".
Example:
docker pull ubuntu
is the same as:
docker pull ubuntu:latest

 IMAGE NAMING STRUCTURE
		repository_name : tag
=============================================================================================
5. USEFUL COMMANDS
=============================================================================================
List available images:
	docker images

Remove an image:
	docker rmi <image_id>

Remove all images:
	docker rmi $(docker images)

List running containers:
	docker ps

List all containers (running + stopped):
	docker ps -a

Remove a container:
	docker rm <container_id>
	docker rm <container_name>

Remove all stopped containers
	docker container prune
	docker rm $(docker ps --filter status=exited -q)

		docker ps --filter status=exited Show stopped containers
		docker ps --filter status=exited -q Show only IDs
		docker rm $(docker ps --filter status=exited -q) Remove all stopped containers
		docker container prune Remove stopped containers (asks confirmation)
		docker rm -f $(docker ps -aq) Remove all containers (force)
To forcefully stop and remove a running container:
	docker rm -f <container_name_or_id>
Explanation:
	- "-f" or "--force" stops the container (if running) and deletes it immediately.

To remove every container on your system:
	docker rm -f $(docker ps -aq)
Explanation:
- "docker ps -aq" lists all container IDs.
- "docker rm -f" deletes them all forcefully.
------------------------------------------------------------------------------------------
UBUNTU DOCKER IMAGE
The Ubuntu Docker image is one of the most commonly used base images in Docker.
It provides a lightweight, clean Ubuntu environment inside a container
so you can run Linux commands and build applications easily.

To download the Ubuntu image:
		docker pull ubuntu
You can also pull a specific version:
		docker pull ubuntu:22.04

you can start a container from the Ubuntu image.

Command:
		docker run -it ubuntu

Explanation:
- "run" creates and starts a new container.
- "-it" makes it interactive (you can type commands inside).
- "ubuntu" is the image name.

You will enter a shell prompt inside the container, like:
root@b9a4f22e8b61:/#

This means you are now inside an Ubuntu environment running inside Docker.

To exit the container, type:
		exit
or press:
		Ctrl + D

This stops the container and brings you back to your host terminal.



====================================================================
1. START A STOPPED CONTAINER
Use the "docker start" command followed by the container name or ID.

Example:
docker start myubuntu

This will start the container in the background.

If you want to attach to it (enter the container terminal again):
docker start -ai myubuntu

Options:
-a Attach to the container output.
-i Keep it interactive (allows you to type commands).

====================================================================
2. RESTART A RUNNING CONTAINER
If the container is already running and you want to restart it (stop + start automatically):
docker restart <container_id or name>

Example:
docker restart webserver
docker restart 4585e3995b52

Docker stops the container, waits a few seconds, and then starts it again.

====================================================================
3. STOP AND RESTART MANUALLY
Stop a running container:
docker stop webserver
docker stop 4585e3995b52

====================================================================
EXECUTION OF COMMANDS INSIDE A RUNNING CONTAINER

In Docker, you can execute commands inside a running container
to inspect, troubleshoot, or manage applications without stopping them.

You donâ€™t need to recreate or restart the container â€”
you can directly access it and run commands just like in a regular Linux shell.


First, identify which containers are currently running.

RUN A COMMAND INSIDE A RUNNING CONTAINER
Use the command:
docker exec [OPTIONS] <container_name_or_id> <command>

This allows you to execute any command inside a running container
without attaching to it permanently.

 BASIC EXAMPLES
Example 1: Check which user is active
docker exec myubuntu whoami

Output:
root

Example 2: List files inside the containerâ€™s root directory
docker exec myubuntu ls /

Example 3: Display environment variables
docker exec myubuntu env

C:\Users\Exaze>docker exec -it dc81f348738f date
Wed Nov 12 10:51:46 UTC 2025

========================================================================================================
VIEWING DOCKER CONTAINER LOGS

Docker provides logging features to help you view and analyze the output (logs)
generated by applications running inside containers.

Logs are essential for debugging, monitoring, and tracking the behavior of containers.

BASIC COMMAND TO VIEW LOGS
Command:
docker logs <container_name_or_id>

Example:
docker logs webserver
Output example:
Starting Nginx server...
Nginx running on port 80
172.17.0.1 - - [12/Nov/2025:10:22:03] "GET /index.html" 200
This command prints all logs from the container since it was created.

VIEW REAL-TIME (LIVE) LOGS
To continuously stream live logs as the container runs, use the "-f" flag.

Command:
docker logs -f <container_name_or_id>

Example:
docker logs -f webserver

Explanation:
- "-f" stands for "follow", similar to "tail -f" in Linux.
- It updates the terminal in real time as new logs are generated.

To stop viewing live logs, press:
Ctrl + C
Example:
docker logs --tail 10 webserver

This displays only the last 10 lines of logs.

To include timestamps in log output:
docker logs --timestamps <container_name_or_id>

Example:
docker logs --timestamps webserver 
Command Description
docker logs <name> View container logs
docker logs -f <name> Stream logs live (follow mode)
docker logs --tail N <name> Show last N log lines
docker logs --timestamps <name> Show logs with timestamps
docker logs -f --tail N <name> Stream last N lines with updates
docker inspect -f ... Check log driver
docker run --log-driver <driver> Use specific log driver

RENAME A DOCKER CONTAINER
The "docker rename" command allows you to change the name of an existing container
without stopping or recreating it.

Itâ€™s useful when you want to give containers meaningful names
(for easier identification and management).
Command format:
docker rename <old_name> <new_name>

Example:
docker rename old_container myubuntu

This changes the containerâ€™s name from "old_container" to "myubuntu".

====================================================================
DOCKER SAVE â€” SAVING DOCKER IMAGES TO A TAR FILE
The docker save command is used to export a Docker image
into a single .tar archive file (tarball).

It is useful when you want to:
- Back up an image.
- Transfer an image to another system without using Docker Hub.
- Store images offline.
BASIC SYNTAX
Command format:
docker save [OPTIONS] -o <file_name>.tar <image_name>:<tag>

Example:
docker save -o ubuntu_backup.tar ubuntu:22.04

Explanation:
- "save" â†’ exports the image.
- "-o" â†’ specifies the output file.
- "ubuntu_backup.tar" â†’ name of the saved file.
- "ubuntu:22.04" â†’ the image you want to save

IMPORTING A DOCKER IMAGE FROM A TAR FILE
When you have a Docker image saved as a .tar archive file,
you can import or load it back into Docker using the docker load or docker import commands.

Both commands are used to restore images, but they serve different purposes.

Use the docker load command when the image was created using docker save.

Command syntax:
docker load -i <file_name>.tar

Example:
docker load -i ubuntu_backup.tar

Explanation:
- "load" tells Docker to import an image from a file.
- "-i" specifies the input tar file (the image archive).

SHOW DOCKER CONTAINER STATISTICS
The docker stats command is used to monitor real-time performance
and resource usage of running Docker containers.

It shows live statistics such as:
- CPU usage
- Memory usage
- Network I/O
- Disk I/O
- PIDs (process count)

This helps you understand container performance and detect issues.

Command:
docker stats

This displays a live, continuously updating table of running containers.


+----------------------------+------------------------------------------+
| Action / Category          | Command / Example                         |
+----------------------------+------------------------------------------+
| show version               | docker --version                          |
| show system info           | docker info                               |
+----------------------------+------------------------------------------+
| list images                | docker images                             |
| pull image                 | docker pull ubuntu                        |
| remove image               | docker rmi ubuntu:latest                  |
| build image                | docker build -t myapp:v1 .                |
| tag image                  | docker tag myapp:v1 myapp:latest          |
+----------------------------+------------------------------------------+
| run container              | docker run ubuntu                         |
| run interactive            | docker run -it ubuntu                     |
| run detached               | docker run -d nginx                       |
| run with name              | docker run --name myubuntu ubuntu         |
| list running containers    | docker ps                                 |
| list all containers        | docker ps -a                              |
| start container            | docker start myubuntu                     |
| stop container             | docker stop myubuntu                      |
| restart container          | docker restart myubuntu                   |
| remove container           | docker rm myubuntu                        |
| force remove container     | docker rm -f myubuntu                     |
+----------------------------+------------------------------------------+
| exec command inside        | docker exec myubuntu ls /                |
| exec interactive shell     | docker exec -it myubuntu /bin/bash        |
| attach to container        | docker attach myubuntu                    |
+----------------------------+------------------------------------------+
| view logs                  | docker logs myubuntu                      |
| follow logs live           | docker logs -f myubuntu                   |
| show last 20 log lines     | docker logs --tail 20 myubuntu            |
+----------------------------+------------------------------------------+
| save image to tar          | docker save -o ubuntu.tar ubuntu:latest   |
| load image from tar        | docker load -i ubuntu.tar                 |
| export container fs        | docker export myubuntu > backup.tar       |
| import fs as image         | docker import backup.tar myubuntu:v1      |
+----------------------------+------------------------------------------+
| prune stopped containers   | docker container prune                    |
| prune unused images        | docker image prune                        |
| full cleanup               | docker system prune -a                    |
+----------------------------+------------------------------------------+
| list networks              | docker network ls                         |
| create network             | docker network create mynet               |
| connect to network         | docker network connect mynet myubuntu     |
+----------------------------+------------------------------------------+
| list volumes               | docker volume ls                          |
| create volume              | docker volume create myvol                |
| remove volume              | docker volume rm myvol                    |
+----------------------------+------------------------------------------+
| inspect container          | docker inspect myubuntu                   |
| view processes             | docker top myubuntu                       |
| resource stats             | docker stats                              |
| port mappings              | docker port myubuntu                      |
+----------------------------+------------------------------------------+
| stop all (Linux)           | docker stop $(docker ps -q)               |
| remove all (Linux)         | docker rm -f $(docker ps -aq)             |
| remove all images          | docker rmi -f $(docker images -q)         |
+----------------------------+------------------------------------------+
| remove all (Win PS)        | docker rm -f (docker ps -aq)              |
+----------------------------+------------------------------------------+

DOCKER RUN OPTIONS
+------------------------------+------------------------------------------+------------------------------------------+
| docker run Option            | Example                                  | Description                              |
+------------------------------+------------------------------------------+------------------------------------------+
| --name                       | docker run --name myapp ubuntu           | Assign a custom container name           |
| -d                           | docker run -d nginx                      | Run in background (detached mode)        |
| -it                          | docker run -it ubuntu /bin/bash          | Interactive terminal shell               |
| --rm                         | docker run --rm ubuntu                   | Remove container after exit              |
| -p                           | docker run -p 8080:80 nginx              | Map host port to container port          |
| -P                           | docker run -P nginx                      | Map all exposed ports to random ports    |
+------------------------------+------------------------------------------+------------------------------------------+
| -v                           | docker run -v myvol:/data ubuntu         | Mount a Docker volume                    |
| -v (bind mount)              | docker run -v C:\app:/app ubuntu         | Mount host folder inside container       |
| --mount                      | docker run --mount type=bind,...         | Advanced mount with full control         |
+------------------------------+------------------------------------------+------------------------------------------+
| -e                           | docker run -e MODE=prod myapp            | Set environment variable                 |
| --env-file                   | docker run --env-file config.env myapp   | Load env variables from file             |
+------------------------------+------------------------------------------+------------------------------------------+
| --network                    | docker run --network mynet ubuntu        | Attach container to a network            |
| --hostname                   | docker run --hostname app1 ubuntu        | Set container hostname                   |
| --ip                         | docker run --network mynet --ip ...      | Assign static IP in user network         |
+------------------------------+------------------------------------------+------------------------------------------+
| --restart always             | docker run --restart always myapp        | Always restart container on failure      |
| --restart unless-stopped     | docker run --restart unless-stopped app  | Restart unless manually stopped          |
| --restart on-failure         | docker run --restart on-failure app      | Restart only if exit code != 0           |
+------------------------------+------------------------------------------+------------------------------------------+
| --memory                     | docker run --memory 512m myapp           | Limit container RAM                      |
| --cpus                       | docker run --cpus 1.5 myapp              | Limit CPU usage                          |
| --cpu-shares                | docker run --cpu-shares 512 myapp        | Set CPU priority                         |
| --memory-swap                | docker run --memory 512m --memory-swap 1g| Limit RAM + Swap                         |
+------------------------------+------------------------------------------+------------------------------------------+
| --privileged                 | docker run --privileged ubuntu           | Full host access (dangerous)             |
| --user                       | docker run --user 1000:1000 ubuntu       | Run container as specific user           |
| --cap-add                    | docker run --cap-add NET_ADMIN ubuntu    | Add extra Linux capabilities             |
+------------------------------+------------------------------------------+------------------------------------------+
| --workdir                    | docker run --workdir /app ubuntu         | Set working directory inside container   |
| --entrypoint                 | docker run --entrypoint /bin/sh ubuntu   | Override container entrypoint            |
| CMD override                 | docker run ubuntu echo â€œhelloâ€           | Replace default CMD command              |
+------------------------------+------------------------------------------+------------------------------------------+
| --detach-keys                | docker run --detach-keys="ctrl-x" ubuntu | Change detach key combination            |
| --log-driver                 | docker run --log-driver json-file ubuntu | Select container logging mechanism       |
| --dns                        | docker run --dns 8.8.8.8 ubuntu          | Use custom DNS server                    |
+------------------------------+------------------------------------------+------------------------------------------+
====================================================================
1. DOCKER IMAGES

A Docker image is a lightweight, read-only template used to create containers.
It contains everything needed to run an application:

- Base operating system
- Application code
- Required libraries
- Environment configuration

Images are immutable and built using layers.

COMMON COMMANDS:
docker images                 List all images
docker pull ubuntu            Download an image
docker rmi myimage            Remove an image
docker inspect nginx          View detailed image information

IMAGE LAYER STRUCTURE (ASCII):

    +-----------------------------+
    |     Application Code        |
    +-----------------------------+
    |      Dependencies           |
    +-----------------------------+
    |       Runtime Layer         |
    +-----------------------------+
    |       Base OS Layer         |
    +-----------------------------+

====================================================================
2. CREATING A NEW DOCKER IMAGE

You create a new Docker image using a Dockerfile.

STEP 1: Create a Dockerfile
Example content:
FROM python:3.10-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "app.py"]

STEP 2: Build the image
docker build -t myapp:1.0 .

STEP 3: Run a container from the image
docker run -p 5000:5000 myapp:1.0

DOCKER IMAGE BUILD FLOW (ASCII):

            +--------------------+
            |   Read Dockerfile  |
            +----------+---------+
                       |
                       v
            +--------------------+
            |  Load Base Image   |
            +----------+---------+
                       |
                       v
            +--------------------+
            | Execute Instructions|
            | (COPY, RUN, etc.)  |
            +----------+---------+
                       |
                       v
            +--------------------+
            | Create Final Image |
            +--------------------+

====================================================================
3. ENVIRONMENT VARIABLES IN DOCKER

Environment variables allow you to configure applications
without modifying your code or rebuilding the image.

WHY USE ENV VARIABLES?
- Set app mode (dev/prod)
- Set ports, keys, database URLs
- Avoid hardcoding config

METHOD 1: Define inside Dockerfile
ENV APP_MODE=production
ENV PORT=5000

METHOD 2: Pass while running
docker run -e APP_MODE=dev -e PORT=3000 myapp

METHOD 3: Use an env file
.env file:
APP_MODE=prod
PORT=8000

Run with file:
docker run --env-file .env myapp

ENV VALUE PRIORITY (Highest â†’ Lowest)
1. docker run -e
2. --env-file
3. ENV in Dockerfile

FLOW (ASCII):

Dockerfile ENV  --->|
docker run -e   --->|--> Final Container ENVIRONMENT
.env file ------->|

====================================================================
4. CMD vs ENTRYPOINT

Both define what runs when a container starts, but they behave differently.

CMD
- Sets the default command
- Can be overridden by the user
- Good for flexible defaults

ENTRYPOINT
- Acts as the main executable
- Not easily overridden
- Good for forcing a specific program to run

COMPARISON TABLE:

+-------------+-----------------------------------------------+
| TYPE        | PURPOSE & BEHAVIOR                            |
+-------------+-----------------------------------------------+
| CMD         | Default command, user can replace it          |
|             | Example: docker run myimg bash                |
+-------------+-----------------------------------------------+
| ENTRYPOINT  | Main executable that always runs              |
|             | CMD becomes default arguments                 |
+-------------+-----------------------------------------------+

EXAMPLE 1: Using only CMD
CMD ["python", "app.py"]

docker run myapp
â†’ python app.py

docker run myapp bash
â†’ bash (CMD overridden)

EXAMPLE 2: ENTRYPOINT + CMD
ENTRYPOINT ["python"]
CMD ["app.py"]

docker run myapp
â†’ python app.py

docker run myapp test.py
â†’ python test.py

====================================================================
====================================================================
1. WHAT IS DOCKER COMPOSE?

Docker Compose is a tool that lets you define and run multiple containers
as a single application using a file called "docker-compose.yml".

Instead of running several docker run commands manually,
you define all services once and start everything with a single command.

Use cases:
- Multi-container apps (example: web + backend + database)
- Local development
- Running dependent containers automatically

====================================================================
2. DOCKER COMPOSE FILE (docker-compose.yml)

A Docker Compose file uses YAML format and describes:
- Services (containers)
- Images or build instructions
- Ports
- Volumes
- Environment variables
- Networks

Example docker-compose.yml:

version: "3.9"
services:
  web:
    image: nginx
    ports:
      - "80:80"

  redis:
    image: redis:alpine

In this example, two containers (web and redis) are started together.

====================================================================
3. IMPORTANT COMPOSE COMMANDS

docker compose up
Starts all containers defined in docker-compose.yml

docker compose up -d
Starts everything in detached (background) mode

docker compose down
Stops and removes containers, networks, images created by Compose

docker compose ps
Lists all containers running through Compose

docker compose logs
Shows logs of all services

docker compose logs web
Shows logs of a specific service

docker compose stop
Stops containers but does NOT remove them

docker compose start
Starts stopped containers

====================================================================
4. DOCKER COMPOSE WORKFLOW (ASCII DIAGRAM)

            +-----------------------------+
            |   docker-compose.yml file   |
            +-------------+---------------+
                          |
                          v
            +-----------------------------+
            |   Parse YAML configuration  |
            +-------------+---------------+
                          |
                          v
            +-----------------------------+
            | Create services/containers  |
            | (web, db, redis, etc.)      |
            +-------------+---------------+
                          |
                          v
            +-----------------------------+
            |  Start containers together  |
            |  Build images if needed     |
            +-----------------------------+

====================================================================
5. USING BUILD OPTION IN COMPOSE

Instead of using an image directly, Compose can build from a Dockerfile.

Example:

services:
  app:
    build: .
    ports:
      - "5000:5000"

In this case:
- Compose reads the Dockerfile in the current folder
- Builds the image
- Starts the container

====================================================================
6. USING ENVIRONMENT VARIABLES IN COMPOSE

You can set environment variables inside docker-compose.yml:

services:
  db:
    image: mysql:8
    environment:
      - MYSQL_ROOT_PASSWORD=root
      - MYSQL_DATABASE=testdb

Or load variables from .env file automatically:
APP_MODE=production
PORT=8080

Compose reads .env automatically and applies values.

====================================================================
7. DEPENDS_ON â€” SERVICE STARTUP ORDER

Use depends_on to ensure containers start in a specific order.

Example:

services:
  app:
    image: myapp
    depends_on:
      - db

  db:
    image: mysql

This ensures:
db starts â†’ then app starts

Note:
depends_on does NOT wait for db to be "ready",
it only waits for the container to start.

====================================================================
8. VOLUMES IN DOCKER COMPOSE

Volumes persist data even after containers are removed.

Example:

services:
  db:
    image: mysql
    volumes:
      - db_data:/var/lib/mysql

volumes:
  db_data:

This keeps MySQL data safe.

====================================================================
9. NETWORKS IN DOCKER COMPOSE

Compose automatically creates a private network.
Containers can communicate using service names.

Example:
web can talk to db using:
mysql://db:3306

Custom networks:

services:
  app:
    image: myapp
    networks:
      - backend

  db:
    image: mysql
    networks:
      - backend

networks:
  backend:

====================================================================

====================================================================
1. WHAT IS A DOCKER REGISTRY?

A Docker Registry is a storage and distribution system for Docker images.
It is where you upload (push) and download (pull) container images.

Think of it like GitHub, but for Docker images.

Common types of registries:
- Docker Hub (public)
- GitHub Container Registry
- GitLab Container Registry
- AWS ECR
- Azure Container Registry
- Google Container Registry
- Self-hosted Docker Registry (private)

====================================================================
2. REGISTRY -> REPOSITORY -> IMAGE TAG

Inside a registry, images are organized like this:

Registry
  â””â”€â”€ Repository
        â””â”€â”€ Image Tags (versions)

Example:
docker.io/library/nginx:latest

Breakdown:
- docker.io      = Registry (Docker Hub)
- library/nginx  = Repository
- latest         = Tag (version of the image)

====================================================================
3. COMMON DOCKER REGISTRY COMMANDS

docker login
Authenticate to a registry

docker logout
Logout from registry

docker pull <image>
Download an image from a registry

docker push <image>
Upload an image to a registry

docker tag <src> <target>
Rename or re-tag an image before pushing

====================================================================
4. PUSHING AN IMAGE TO A REGISTRY (FULL PROCESS)

Step 1: Login  
docker login

Step 2: Tag your image  
docker tag myapp:1.0 username/myapp:1.0

Step 3: Push the image  
docker push username/myapp:1.0

Now your image is available online.

====================================================================
5. PULLING AN IMAGE FROM A REGISTRY

docker pull username/myapp:1.0

After pulling, you can run it:
docker run username/myapp:1.0

====================================================================
6. LOCAL PRIVATE DOCKER REGISTRY

You can run your own private registry locally like this:

docker run -d -p 5000:5000 --name registry registry:2

This starts a private registry at:
http://localhost:5000

Pushing to private registry:

docker tag myapp:1.0 localhost:5000/myapp:1.0
docker push localhost:5000/myapp:1.0

Pulling from private registry:

docker pull localhost:5000/myapp:1.0

====================================================================
7. DOCKER REGISTRY WORKFLOW (ASCII DIAGRAM)

            +-----------------------------+
            |      Docker Build Image     |
            +--------------+--------------+
                           |
                           v
            +-----------------------------+
            |      Tag the Image          |
            |  (username/app:version)     |
            +--------------+--------------+
                           |
                           v
            +-----------------------------+
            |        Push to Registry     |
            +--------------+--------------+
                           |
                           v
            +-----------------------------+
            |   Image Stored in Registry  |
            +--------------+--------------+
                           |
                           v
            +-----------------------------+
            |       Pull on any system    |
            +-----------------------------+

====================================================================
8. WHY USE A REGISTRY?

- Share images with your team
- Deploy to cloud platforms
- Version control for container builds
- Secure private images
- Automated CI/CD pipelines can pull images easily

====================================================================
9. DOCKER HUB RATE LIMITS (IMPORTANT)

Anonymous users have pull rate limits.
If you pull too often, Docker may block requests temporarily.

Solution:
docker login
or use a private registry.

====================================================================

====================================================================
1. DOCKER ENGINE

Docker Engine is the core part of Docker.
It is responsible for building, running, and managing containers.

It uses a client-server architecture:
- Docker Client (CLI)
- Docker Daemon (dockerd)
- REST API
- Container Runtime (containerd / runc)

====================================================================
2. DOCKER ENGINE ARCHITECTURE (ASCII DIAGRAM)

               +----------------------------+
               |      Docker Client         |
               |   (docker commands)        |
               +-------------+--------------+
                             |
                  Docker CLI sends commands
                             |
                             v
               +----------------------------+
               |       REST API Server      |
               | (dockerd listens on socket)|
               +-------------+--------------+
                             |
                             v
               +----------------------------+
               |      Docker Daemon         |
               |   Manages images, volumes, |
               |   networks and containers  |
               +-------------+--------------+
                             |
                             v
               +----------------------------+
               |    containerd runtime      |
               +-------------+--------------+
                             |
                             v
               +----------------------------+
               |      runc (low-level)      |
               | Creates containers using    |
               | Linux kernel features       |
               +----------------------------+

====================================================================
3. COMPONENTS OF DOCKER ENGINE

1. Docker Client  
   - The "docker" command you type in terminal.

2. Docker Daemon  
   - Runs in background.
   - Manages containers, images, volumes, networks.

3. Docker API  
   - Client talks to daemon using REST API over Unix socket.

4. containerd  
   - High-level container lifecycle manager.

5. runc  
   - Actually creates containers using Linux namespaces and cgroups.

====================================================================
4. HOW A DOCKER COMMAND WORKS (FLOW)

docker run nginx

Flow:
Docker CLI â†’ Docker Daemon â†’ Pull image â†’ Create container â†’ Start container

====================================================================
5. DOCKER STORAGE

Docker uses different storage mechanisms to store:
- Images
- Containers
- Volumes
- Layers

There are three main storage types:
1. Image Layers  
2. Container Layer  
3. Volumes

====================================================================
6. DOCKER STORAGE TYPES (DETAILED)

1. Image Layers (Read-Only)
   - Each instruction in a Dockerfile creates a layer.
   - Layers are shared across containers.

2. Container Layer (Read-Write)
   - Temporary and exists only while the container is running.
   - Data stored here is LOST when container is removed.

3. Volumes (Persistent Storage)
   - Recommended for databases.
   - Data survives container recreation.

====================================================================
7. VOLUME TYPES

1. Anonymous Volumes  
   - Automatically created and usually temporary.

2. Named Volumes  
   - Defined by user.
   - Stored under /var/lib/docker/volumes/

3. Bind Mounts  
   - Maps a host folder directly into container.
   - Example: /home/user/data:/data

====================================================================
8. DOCKER STORAGE FLOW (ASCII)

             +----------------------------+
             |      Docker Image          |
             |     (Read-Only Layers)     |
             +--------------+-------------+
                            |
                            v
             +----------------------------+
             |    Container Layer         |
             | (Temporary, RW filesystem) |
             +--------------+-------------+
                            |
                            v
             +----------------------------+
             |         Volumes            |
             | (Persistent Application     |
             |           Data)            |
             +----------------------------+

====================================================================
9. DOCKER NETWORKING

Docker networking allows containers to communicate:
- With each other
- With the host system
- With the outside world

====================================================================
10. TYPES OF DOCKER NETWORKS

1. bridge (default)
   - Most commonly used.
   - Containers get their own IP and can talk to each other.
   - Example default network: docker0

2. host
   - Shares hostâ€™s network directly.
   - No isolation.

3. none
   - No network access for the container.

4. overlay
   - Used for multi-host communication (Docker Swarm).

5. macvlan
   - Assigns a MAC address to the container.
   - Container appears as a physical device on the network.

====================================================================
11. CHECK NETWORKS AND DETAILS

docker network ls
List all networks

docker network inspect bridge
Show network details

docker network create mynet
Create custom network

docker run -d --network=mynet nginx
Run container inside custom network

====================================================================
12. DOCKER NETWORK FLOW (ASCII DIAGRAM)

                +-------------------------+
                |    Host Machine         |
                +-----------+-------------+
                            |
                            v
                +-------------------------+
                |   Docker Networks       |
                | (bridge / host / none)  |
                +-----------+-------------+
                            |
                            v
        +----------+   +----------+   +----------+
        | Container|   | Container|   | Container|
        |   A      |<--|   B      |-->|    C     |
        +----------+   +----------+   +----------+
              Communication happens through networks

====================================================================
13. WHY NETWORKING MATTERS IN DOCKER

- Containers need to communicate with databases
- Web servers need internet access
- Microservices architecture depends on inter-container communication
- Helps isolate and secure applications

====================================================================
====================================================================
1. CONTAINER ORCHESTRATION

Container orchestration is the automated management of containerized
applications, including:

- Deploying containers
- Scaling containers up or down
- Restarting failed containers
- Managing load balancing
- Rolling updates and rollbacks
- Service discovery
- Ensuring high availability

It is required when applications become too large to manage manually.

Examples of orchestration tools:
- Docker Swarm
- Kubernetes
- Amazon ECS
- Nomad

====================================================================
2. WHY CONTAINER ORCHESTRATION IS IMPORTANT

1. Scalability  
   Easily increase number of containers based on traffic.

2. High Availability  
   If a container fails, orchestrator replaces it automatically.

3. Load Balancing  
   Distributes traffic across containers.

4. Self-Healing  
   Automatically restarts or replaces failed containers.

5. Automated Deployment  
   Rolling updates, zero-downtime deployments.

6. Multi-node Management  
   Run containers across hundreds of machines.

====================================================================
3. ORCHESTRATION WORKFLOW (ASCII DIAGRAM)

            +---------------------------------+
            |   Desired State (User wants)    |
            |   e.g., "Run 3 replicas"        |
            +----------------+----------------+
                             |
                             v
            +---------------------------------+
            |   Orchestrator System           |
            |  (Swarm, Kubernetes, etc.)      |
            +----------------+----------------+
                             |
                             v
            +---------------------------------+
            |   Actual State (Current system) |
            +---------------------------------+
                             |
                             v
            Continually adjusts containers to match desired state

====================================================================
4. DOCKER SWARM

Docker Swarm is Dockerâ€™s native container orchestration tool.
It allows you to create a cluster of Docker nodes that work together.

Swarm consists of:
- Manager Nodes (control plane)
- Worker Nodes (run containers)

====================================================================
5. DOCKER SWARM KEY FEATURES

- Built-in load balancing
- Rolling updates
- Service scaling (replicas)
- Self-healing
- Secure by default (TLS encryption)
- Easy setup (simple commands)

====================================================================
6. SWARM ARCHITECTURE (ASCII DIAGRAM)

                 +----------------------+
                 |   Manager Node       |
                 |  (decides actions)   |
                 +---------+------------+
                           |
                 Schedules Services, Replicas
                           |
           +---------------+----------------+
           |                                |
+-------------------+             +-------------------+
|   Worker Node 1   |             |   Worker Node 2   |
| Runs containers   |             | Runs containers   |
+-------------------+             +-------------------+

Managers decide; workers execute.

====================================================================
7. IMPORTANT SWARM COMMANDS

docker swarm init
Initialize swarm (manager node)

docker swarm join
Join another node as worker/manager

docker service create --replicas 3 nginx
Create a service with 3 replicas

docker service ls
List running services

docker node ls
List all nodes in the swarm

docker service scale myservice=5
Scale service to 5 replicas

docker service update myservice
Update a service (rolling update)

====================================================================
8. DOCKER SWARM DEPLOYMENT FLOW

1. Convert containers into services  
2. Define number of replicas  
3. Swarm schedules tasks to nodes  
4. Containers created across workers  
5. Load balancing applied automatically  
6. If a container fails â†’ Swarm recreates it  

====================================================================
9. KUBERNETES INTRODUCTION

Kubernetes (K8s) is the most powerful and widely used container
orchestration system. Created by Google, now maintained by CNCF.

Kubernetes is designed for:
- Large-scale deployments
- Fully automated rollouts
- Intelligent load balancing
- Self-healing containers
- Multi-node, multi-region clusters
- Enterprise grade reliability

====================================================================
10. KUBERNETES COMPONENTS (HIGH LEVEL)

1. Master (Control Plane)
   - API Server
   - Scheduler
   - Controller Manager
   - ETCD (cluster database)

2. Worker Nodes
   - Kubelet
   - Kube Proxy
   - Pods (containers run here)

====================================================================
11. KUBERNETES BASIC CONCEPTS

Pod  
- Smallest deployable unit  
- Contains 1 or more containers  

Deployment  
- Manages multiple replicas of Pods  
- Handles scaling and rolling updates  

Service  
- Stable networking for Pods  
- Load balancer inside Kubernetes  

Namespace  
- Logical separation inside cluster  

====================================================================
12. KUBERNETES ARCHITECTURE (ASCII DIAGRAM)

                    +-----------------------------+
                    |       Control Plane         |
                    |  API Server, ETCD,          |
                    |  Scheduler, Controllers     |
                    +---------------+-------------+
                                    |
                                    |
                         +----------+-----------+
                         |                      |
             +-------------------+    +-------------------+
             |    Worker Node    |    |    Worker Node    |
             +-------------------+    +-------------------+
             | Kubelet           |    | Kubelet           |
             | Kube Proxy        |    | Kube Proxy        |
             | Pods/Containers   |    | Pods/Containers   |
             +-------------------+    +-------------------+

====================================================================
13. KUBERNETES VS DOCKER SWARM (QUICK COMPARISON)

+-----------------------+---------------------+------------------------+
| FEATURE               | DOCKER SWARM        | KUBERNETES             |
+-----------------------+---------------------+------------------------+
| Setup Complexity      | Simple              | Complex                |
| Scalability           | Medium              | Very High              |
| Rollouts              | Good                | Excellent              |
| Self-Healing          | Yes                 | Very advanced          |
| Load Balancing        | Built-in            | Built-in + advanced    |
| Best For              | Small/medium apps   | Enterprise-level apps  |
+-----------------------+---------------------+------------------------+

====================================================================



