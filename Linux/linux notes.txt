INSTALLATION OF VirtualBox AND UBUNTU SETUP
-------------------------------------------
1) Install VirtualBox on Windows
	Download VirtualBox from its official site and run installer.
	Install by double-clicking the .vbox-extpack or from VirtualBox ‚Üí File ‚Üí Preferences ‚Üí Extensions.

2) Prepare Ubuntu ISO
	Download an Ubuntu Desktop LTS ISO (e.g., 24.04 LTS) from ubuntu.com. Save it where you can browse to it.

3) Create a new virtual machine (VM)

	Open VirtualBox ‚Üí New.
	Name: Ubuntu 
	ISO image: select ubuntu iso file (make sure this ubuntu-iso file in 'VirtualBox VMs' folder)
	Memory: 4096 MB (4 GB) recommended if your host has ‚â•8GB. If your host has 8GB total, use 2048 MB.
	Hard disk: Create a virtual hard disk now ‚Üí VDI (VirtualBox Disk Image) ‚Üí Dynamically allocated ‚Üí Size 30 GB (or at least 25 GB).

4) Configure VM settings (important)

	CPUs: assign 2 (or half of your cores; leave at least 2 for host).

5) Start the VM and install Ubuntu

	Select VM ‚Üí Start. It boots from the ISO.
	Choose Try Ubuntu (optional) or Install Ubuntu. (Choose Install to proceed.)
	Follow installer:
		Select language, keyboard layout.
		Normal installation (includes utilities & browser) is fine.
		Choose Erase disk and install Ubuntu ‚Äî this affects only the VM‚Äôs virtual disk, not your host drive.
		Set timezone, username, password.
		Wait until installation finishes, then reboot VM when prompted.

---------------------------------------------------------------------
üîπ 1. UNIX came first
	In the 1960s‚Äì70s, engineers at Bell Labs (AT&T) developed UNIX.
	It was revolutionary because it introduced:
		Multiuser support (many users can log in at once)
		Multitasking (run multiple programs at once)
		File-based structure (/home, /usr, /etc, etc.)
üí° UNIX became the foundation for many modern systems.

üîπ 2. Linux was inspired by UNIX
	In 1991, Linus Torvalds (a Finnish student) wanted to make a free version of UNIX for his PC.
	He created the Linux kernel, which behaves like UNIX but is completely free and open-source.
üëâ So, Linux = UNIX-like system, not UNIX itself.
---------------------------------------------------------------------
‚úÖ What is Linux?

Linux is an operating system ‚Äî just like Windows and macOS.

üß† An Operating System (OS) is software that manages:
	**Computer hardware (CPU, RAM, storage‚Ä¶)
	**Programs (apps)
	**User interaction (keyboard, mouse, screen‚Ä¶)
But one big difference:
	‚úÖ Linux is open-source
	‚ùå Windows/macOS are closed-source


‚úÖ Where do we use Linux?

Linux is everywhere!

	‚úî 96% of Cloud servers run Linux
	‚úî ALL supercomputers run Linux
	‚úî Android OS is built on Linux
	‚úî Websites, apps, databases ‚Äî run on Linux servers
	‚úî DevOps, Data Engineering ‚Üí Linux skills required
	‚úî Cybersecurity & Ethical Hacking ‚Üí Linux mandatory
	‚úî IoT Devices (routers, smart TVs, robots‚Ä¶)


‚úÖ Why should you learn Linux?


	Linux is needed for:
	‚úî Running servers (Node, Django, Java apps)
	‚úî Managing PostgreSQL, MySQL databases
	‚úî Using DevOps tools (Docker, Jenkins, CI/CD)
	‚úî Cloud computing jobs (AWS, Azure)

Companies expect developers to deploy applications on Linux environments.


‚úÖ How do we use Linux? (Very important üî•)

	Linux can be used in 2 ways:

		1Ô∏è‚É£ GUI interface (like Windows)

			Click menus, open software visually
			Example: Ubuntu Desktop

		2Ô∏è‚É£ Command Line / Terminal (main focus for developers!)

			You type commands to control the system

	----------------------------------------------------------------------
	üî∏ UNIX = The ancestor, closed-source, paid, old but stable.
	üîπ Linux = The child inspired by UNIX, open-source, free, and modern.
	---------------------------------------------------------------------
	both share similar architecture:
	__________________________________

		User
		|
		‚îÇ   type our commands in terminal
		‚îÇ  (commands)
		‚ñº
		Shell
		|
		‚îÇ   interpreter that understands your commands
		‚îÇ  (passes commands to karnel) (bash -- defalut)
		‚ñº
		Kernel
		‚îÇ
		|   engine that does the actual work
		‚îÇ  (controls)
		‚ñº
		Hardware
	______________________________________________________

	-----------------------------------------------------------------
	Part	        Role
	------------------------------------------------------------------
	Terminal	The screen where you type our commands
	Shell	        The interpreter that understands your commands(default BASH)
	Kernel	        The engine that does the actual work
	------------------------------------------------------------------
	Bash is the default SHELL in most Linux systems.



	Practical Example:
		 ________________________________
		|$ ls                            |
		|                                |
		|Documents  Downloads  Pictures  |
		|________________________________|

		Terminal:          The window you see
		Bash (Shell):      Reads ls, sends it to Kernel
		Kernel:            Gets folder list from hard drive
		Terminal:          Displays output on your screen
--------------------------------------------------------------------------------------
++++++++++++++++++COMMANDS++++++++++++++++

Commands are case senstitive, so Date is NOT the same thing as date.
1. date
	-> Fri Oct 31 11:50:34 UTC 2025
2. ncal     ->new calendedar gives vertical calender
3. cal      ->old calender gives horizontal calender
4. clear    -> To clear screen 
--------------------------------------------------------------------------------------
+++++++++++++++++COMMAND STRUCTURE++++++++++++++
 _____________________________
|                             |
| command -options arguments  |
|_____________________________|

most commands support multiple options that modify their behavior. We can decide which option to include, if any, when we execute a command.

similarly, many commands accept arguments(the thing that the command acts upon or uses)
example::
$ echo mwahahaha
	->mwahahaha
The echo command is extremly simple. it takes the arguments we provide to it and print them out. it echoes them back at us.
$ ncal 2021       -> it gives entire year calender all 12 months of year 2021
$ ncal july 1969  -> it gives only july month of 1969 year

===================================================================================================================================

 man stands for manual
		It is used to display documentation for Linux commands, programs, system functions, and more.

Man Page Structure (What You‚Äôll See Inside)

Most manual pages follow this structure:
-----------------------------------------
Section Title		Meaning
NAME				Command or function name + short description
SYNOPSIS			How to use it (syntax, options, parameters)
DESCRIPTION			Detailed explanation
OPTIONS	All	 		flags/switches (ex: -l, --help)
EXAMPLES			How to use it practically
FILES				Related system/config files
SEE ALSO			Similar commands or references
AUTHOR / BUGS		Author details & bug info

‚úÖ Useful Man Page Commands (while reading)
---------------------------------------------
Key	                Action
Space / Page Down	Scroll down
b	                Scroll up
q	                Quit
/ word	            Search for a word
n					Next search match
Shift + g			Go to end
1 + g				Go to start


üìö Linux Manual Sections (1 to 9)
		Manual pages are divided into 9 sections, each category containing specific types of documentation.
		Section	                  			Description
		1 ‚Äì User Commands					Regular commands for users (like ls, cp, mkdir).
		2 ‚Äì System Calls					Functions provided by the kernel (open, read, write).
		3 ‚Äì Library Functions				C library functions (printf, scanf, malloc).
		4 ‚Äì Special Files / Devices			Describes device files in /dev (like /dev/sda, /dev/null).
		5 ‚Äì File Formats & Configuration    Files	Explains config files and formats (/etc/passwd, crontab syntax).
		6 ‚Äì Games & Screensavers			Games available on the system (less important today).
		7 ‚Äì Miscellaneous					Conventions, protocols, standards, etc. (like man 7 signal).
		8 ‚Äì System Administration Commands	Commands for admin/root (mount, useradd, iptables).
		9 ‚Äì Kernel Routines (Linux-specific)	Internal kernel functions used by developers.

==================================================================================================================================

üß† What Is a Command in Linux?
--------------------------------
	A command in Linux is any instruction you type into the shell (terminal) that tells the operating system to perform a specific task 
		‚Äî such as listing files, copying data, or managing users.

‚öôÔ∏è Main Types of Linux Commands
--------------------------------
Linux commands can be divided into 5 main categories:

Type	                            Description
----								-----------	
1. Internal (Built-in) Commands   	Commands built directly into the shell (no external program needed).	
                                    examples:: cd, echo, pwd, exit, history
2. External Commands	            Stored as separate executable files in system directories (like /bin, /usr/bin).	
									examples:: ls, cp, mv, grep, cat
3. Shell Scripts	                A file that contains a series of Linux commands written together.	
									examples:: ./backup.sh, bash script.sh
4. Alias Commands	                Shortcuts or custom names you create for longer commands.	
									examples:: alias ll='ls -l'
5. Functions	                    User-defined mini-programs inside the shell, similar to functions in programming languages.	
									examples:: myfunc() { echo "Hello $1"; }

üß≠ How to Identify the Type of a Command
----------------------------------------
Use the type command:

 ________________
|                |
|  type command  |
|________________|

type cd       #cd is a shell builtin
type ls       #ls is aliased to 'ls --color=auto'
type echo     #echo is a shell builtin
type update   #
==================================================================================================================================
+++++++++++++++++++++                    üß≠ Navigation Commands in Linux (File System Travel)                ++++++++++++++++++++
==================================================================================================================================

These commands help you:
	-> Move between folders
	-> Know where you currently are
	-> List files/folders
	-> Go back, up, or to home directory

1. pwd ‚Äì Print Working Directory
	--> Shows the current location of your terminal. 
	example::
		pwd  #/home/jaswanth/Documents

2. ls ‚Äì List Directory Contents
	--> Used to list files and folders in the current location.

	Command				Description
	ls					List files and folders
	ls -l				Long listing (details like permissions, size, owner, date)
	ls -a				Show hidden files (that start with .)
	ls -la				Long listing + hidden files
	ls /path			List contents of another directory
	  
3. cd ‚Äì Change Directory 
	--> used to Move into folders from current directory.
	Command				Meaning
	cd foldername		Go inside a folder
	cd ..				Go back/up one level
	cd ../..			Go up two levels
	cd ~ or just cd		Go to Home directory
	cd /				Go to root directory (/)
	cd /path/to/folder	Go to specific path
	cd -				Switch to previous directory

	example::
		cd Documents         # Go into Documents
		cd ..                # Go back
		cd /etc              # Go to /etc directory
		cd ~                 # Go to home
		cd -                 # Toggle back to last directory
4. tree ‚Äì View Directory Structure (Optional)
	-->Displays folders and files in a tree-like structure.
	example::
		tree /home/jaswanth/
		  /home/jaswanth/
    	  ‚îú‚îÄ‚îÄ Documents
    	  ‚îÇ     ‚îî‚îÄ‚îÄ Projects
    	  ‚îî‚îÄ‚îÄ Downloads

	Directory Path Concepts (Very Important)
	Type	      		Symbol						Meaning
	Absolute Path		/home/user/docs/file.txt	Full path from the root /
	Relative Path		../Pictures					Path from your current directory
	Home directory		~							/home/username
	Parent directory	..							One level up
	Current directory	.							Present folder
 

 # Navigation Exercise

Download the above file, **unzip it**, and drag the resulting **`Farm`** folder to your **Desktop**.    The Farm folder contains the following subdirectories:

```bash
Farm/
	Coop/ 
		Chickens/
		Geese/
	Stable/
		Horses/
```

**From this point forward, ONLY use the terminal to accomplish the following:**

1. Open a new terminal window. Navigate to the `Farm` folder.
		cd Farm
2. List the contents of the `Farm` directory.
		ls 
3. "Move" into the `Coop` folder.
		cd Coop
4. List the contents of the `Coop` folder.
		ls
		--> Chickens,Geese
5. "Move" into the `Chickens` folder.
		cd Chickens
6. List out the chickens in the `Chickens` folder.  How many are there?
		ls
		-->6
7. One of the chickens is very very old, which one is it? (which file in the `Chickens` folder has the oldest modification time?) Use a command to figure it out!
		ls --sort=time -la
		-->Elvis , feb 14
8. In a **single** command, move from the `Chickens` directory to the `Geese` directory.  Consult the folder structure written out above if needed.
		cd ~/Farm/Coop/Grees
		cd /home/jaswanth/Farm/Coop/Grees
9. How many geese (files) are in the `Geese` directory?
		ls
		-->4
10. One of the geese is sitting on a golden egg!  It's larger than the other geese. Which one is it?  
	(which file in the `Geese` folder is the largest?).  Use a command to figure it out!
		ls -l --sort=size 
		-->Muffin
11. Navigate to the `Horses` directory.  Consult the folder structure written out above, if needed.
		cd ../../Stable/Horese
12. How many horses are in the `Horses` directory?
		ls 
		-->4
13. Wait! There is a hidden horse in the `Horses` directory! What is it's name??
		ls -la
		-->Tory

=============================================================================================
+++++++++++++++++++++         CREATING FILES AND FOLDERS                 ++++++++++++++++++++
=============================================================================================

1. Create a Folder (Directory)
	mkdir --> make directories
		mkdir [OPTION]... Directory...
		--> Create the directory(ies), if they do not already exist.
 
	Command								Description
	mkdir folder_name					Creates a folder.
	mkdir folder1 folder2				Creates multiple folders.
	mkdir -p parent/child1/child2		Creates nested folders (also creates parent folder if it doesn't exist).

		Examples::
			mkdir my_folder                 
			mkdir folderA folderB
			mkdir -p projects/python/app

2. Exploring file type
	file --> determine file type
			 file prints the type of that file
		example::
			file colors.txt
				-->colors.txt: ASCII text
			file Farm
				-->Farm: directory

3. Create a File

	There are multiple ways to create a file:
		TOUCH--> 
					----touch [OPTIONS]..FILE----
				update the access and modification times of each file to the current time.
				 A file argument that does not exits is created empty, unlwss -c or -h is supplied
				used to create a new file from the command line.  touch filename.ext
				if we try to se touch with a file that already exits,it will simply update the access and modification dates to current time. 

	Command						Use Case
	touch filename				Creates an empty file or updates timestamp if file exists.
	cat > filename				Create a file and write content. (Press Ctrl + D to save and exit).
	nano filename				Opens a text editor to write content.
	echo "text" > filename		Creates a file with text (overwrites if exists).
	echo "text" >> filename		Adds text to the end of a file (append mode).

	Examples::
		touch notes.txt
		touch app.js index.html style.css		# creating multiple files at a time
		cat > todo.txt         		           	# Type text, then press Ctrl + D to save
		nano report.txt       					# Write, then press Ctrl + O (save) and Ctrl + X (exit)
		echo "Hello Linux" > file1.txt
		echo "More content" >> file1.txt

Making Files And Folders Exercise
----------------------------------
	1.Create a new folder called my-app
		mkdir my-app
	2.Navigate to my-app and inside create two new empty files called README.md and package.json
		cd my-app
		touch README.md package.json
	3.Still inside of my-app create a new folder called public. Without cd-ing into public, create an index.html file inside of it.
		mkdir public 
		touch public/index.html
	4.Create a new folder called src inside of my-app.  Navigate inside of it.
		mkdir src 
		cd src
	5.Using a single line, create the following four files inside of src: App.css, App.js, index.css, and index.js
		touch App.css App.js index.css index.js
	Your folder structure should now look like this:
		my-app/
		  README.md
		  package.json
		  public/
		    index.html
		  src/
		    App.css
		    App.js
		    index.css
		    index.js
	BONUS:
üí° 		Using a single command, create a new directory inside of `src` called `components`,
		and inside of that new `components` directory create a new directory called `Navbar`.   
		Do this using a single command, without first creating the `components` directory.
			
			mkdir -p components/Navbar

---------------------    NANO    -------------------------------
nano
	nano is a simple text editor that we can access right from the terminal.
	its far more accessible thean other papular command-line editiors like vim and emacs.

	nano includes all basic text editing functionality
	you would expect: search, spellcheck, syntax highlighting, etc.


1. How to Open a File in Nano
	Purpose	                                                Command
	Open Nano with a new/existing file						nano filename
	Open Nano in read-only mode								nano -v filename
	example::
		nano notes.txt
		--> If the file doesn‚Äôt exist, Nano will create it once you save.
2. Nano Interface Overview

	When you open Nano, you'll see:

		GNU nano 6.2                         notes.txt
		---------------------------------------------
		| Here is your file content...              |
		|                                           |
		---------------------------------------------
		^G Help  ^O Write Out  ^W Where Is  ^K Cut  ^U Paste  ^X Exit
		(Shortcuts are shown at bottom)
		    ^ means Ctrl key (Example: ^X = Ctrl + X)

3. Most Useful Nano Shortcuts

			------------------------------------------------------------------
			| Action               | Shortcut                                |
			| -------------------- | --------------------------------------- |
			| Save file            | **Ctrl + O** (then press Enter)         |
			| Exit Nano            | **Ctrl + X**                            |
			| Save & Exit directly | **Ctrl + X**, then press **Y**, Enter   |
			| Cut a line           | **Ctrl + K**                            |
			| Paste a line         | **Ctrl + U**                            |
			| Undo                 | **Alt + U**                             |
			| Redo                 | **Alt + E**                             |
			| Search text          | **Ctrl + W**                            |
			| Next Search          | **Alt + W**                             |
			| replace (search)     | **Ctrl + \**                            |
			| Go to a line number  | **Ctrl + _** (then type numer + Enter)  |
			| Justify text (align) | **Ctrl + J**                            |
			| Mark text (select)   | **Ctrl + Shift + 6**                    |
			| Copy selected text   | **Alt + 6**                             |
			| Delete a character   | Backspace or Ctrl + D                   |
			| Spell check          | **Ctrl + O** then **Ctrl + S**          |
			------------------------------------------------------------------

4. Editing and Saving a File

	‚úèÔ∏è To write content:
		Just start typing.
	üíæ To Save:
		Press Ctrl + O
		Press Enter to confirm filename
	üö™ To Exit:
		Ctrl + X
		If there are unsaved changes, it asks:
			--------------------------------------------------------------
			| Save modified buffer? (Answering "No" will DISCARD changes) |
			| Y Yes   N No   ^C Cancel									  |
			---------------------------------------------------------------
5. Open a File in a Specific Line

	nano +10 example.txt
		--> This opens example.txt at line number 10

6. Open Nano in Read-Only Mode

	nano -v filename
		-->You can view the file but not edit.


Nano Exercise

	[NanoExercise.zip](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc6ee08f-2e6f-4fe9-b8f4-98ba8d963c6b/NanoExercise.zip)

	Download the above zip file.  Unzip it and then navigate to the resulting directory using the command line.

	## Part 1

	1. Open up the `recipe.txt` file using `nano`
		cd NanoExercise
		nano recipe.txt
	2. On line 3, add your own name after `Author:` so that it says `Author: Stevie Wonder` or whatever your name is
		jaswanth kumar
	3. Whoever wrote this recipe didn't know how to spell "parmesan", so instead they wrote "parm".  
		Please update the two instances of "Parm" to "Parmesan".  
		You can do this manually or by using nano's replace feature.
		Ctrl+\ --> parm -- enter --parmesan  --> y
	4. Write out your changes! Close the file.
		ctrl+O
		enter for file name
		ctrl+x

	## Part 2

	1. Open up the `website.html` file with `nano`
		nano website.html
	2. This html file contains a simple website for a fictional restaurant called "Ristorante Colt".  
		You recently purchased the restaurant and have decided to change its name! 
		Please replace all instance of "Ristorante Colt" with your new restaurant's name.  
		Do this using a nano shortcut, rather than manually replacing each one.

		Ctrl+\ --> Ristorante Colt -- enter -- jaswanth jas  --> a
		total 4 occurrences 

	3. Save your changes and close the file!
		ctrl+O
		enter for file name
		ctrl+x

	## Part 3

	1. The `country-data.json` file contains a large country dataset, with over 39,000 lines of json!
		nano +15399 country-data.json
	2. Unfortunately, there is a typo on line **15399**.  It says "Hondras" but it should say "Honduras".  
		Please fix this!  Rather than scrolling for a decade, use a nano shortcut to jump to line **15399**.
		Ctrl+\ --> Hondras -- enter -- jaswanth jas  --> a
	3. **Bonus:** Figure out how to tell `nano` to open the file at exactly **15399**.
		nano +15399 country-data.json
	## Bonus

	1. The `review.txt` file contains a text review of the Cacio E Pepe recipe from `recipe.txt`

	2. Open up the `recipe.txt` file using `nano` and scroll to the bottom. 

	3. Using a nano shortcut we have not covered, insert the contents of `review.txt` at the bottom of `recipe.txt`.


=============================================================================================
+++++++++++++++++++++         DELETE/REMOVE COPYING MOVING               ++++++++++++++++++++
=============================================================================================



1. REMOVE
	--> rm   remove files or directories
			rm [OPTION]... [FILE]...
			example::
				rm app.js                # single file
				rm index.html style.css  # multiple files

		rm deletes files, there is no undo or recycling bin to retrive then from! they are gone!

		rm -d foldername
			--> remove empty directory
	
		Option		    Meaning
		-r				Recursive delete
		-f				Force delete (no warning)

		‚ö† WARNING: rm -rf / will erase the full system ‚Äî never run this ‚ùå

			rm -r folder   		# Delete Folder + All Its Contents (Recursive)
				--> removes everything inside the folder
				
			rm -rf foldername
				--> Delete everything inside the folder without asking confirmation

			rm -i file.txt      # for interactive safe delete files
				--> Safe Delete Mode (Ask before deletion)

			rm -ri file.txt      # for interactive safe delete folder
				--> Safe Delete Mode (Ask before deletion every file and folder)


2. MOVING
	--> rv   movie (rename) files 
			-->mv used to move files and directories from location to another.
			rv [OPTION]... [-T] SOURCE DEST
			rv [OPTION]... SOURCE... DEST...

			example::
				mv file1.txt /home/user/Documents/   		# move single file to another folder
				mv file1 file2 folder/						# movie multiple files into another folder
				mv oldname.txt newname.txt					# rename a file
				mv oldfolder_name newfolder_name			# rename a folder
				mv folder1 /home/user/Documents/            # moving folder to another folder


3. COPYING
	--> cp   copy files and directories
			cp [OPTION]... [-T] SOURCE DEST
			cp [OPTION]... SOURCE... DEST...

			example::
					cp file1.txt file2.txt					# file2.txt becomes a copy of file1.txt
					cp file.txt /path/to/folder/			# Copy to a Folder
					cp file1 file2 folder/					# Copy Multiple Files
					cp -r folder1 folder2                   # Copy a Full Directory (FOLDER) - Recursively copies all subfolders & files



			--> cp sheep.txt dolly.txt
					to create a copy of sheep.txt called dolly.txt

Deleting, Moving & Copying Exercise

	## Part 1: Creating The Folders & Files

	Before we can delete, move, or copy things...we need things! It's time to get some more practice using `touch` and `mkdir`

	Please create a new directory somewhere on your machine called `Bootcamp`.  Inside of it, create the the folders and files indicated below:

	```bash
	**Bootcamp/**
		**FallCohort/**
			Italo.txt
			Edgar.txt
			Linus.txt
			Sara.txt 
			Silvio.txt
			**Waitlist/**
				Hanna.txt
				Haris.txt
				Netta.txt
		**WinterCohort/**
			Santiago.txt
			Iris.txt
			Naomi.txt
	```

	- Sadly `Edgar` had to drop out of the course.  Delete the `Edgar.txt` file in `FallCohort`
		rm Bootcamp/fallcohort/edgar.txt

	- This means we now have space in our Fall Cohort to move someone off of the waitlist.  Please move `Netta.txt` from the `Waitlist` folder into the `FallCohort` folder.
		mv Bootcamp/fallcohort/waitlist/netta.txt Bootcamp/fallcohort/

	- Please delete the `Waitlist` folder and its contents
		m -r Bootcamp/fallcohort/waitlist/*
	
	- It turns out that I misspelled Sara.  She spells her name "Sarah" with an "h" at the end.  Please rename the `Sara.txt` file to `Sarah.txt`
		mv fallcohort/sara.txt fallcohort/sarah.txt
	
	- Unfortunately Italo is having a bit of a personal emergency, and he would like to move to our WinterCohort.  
		Please move the `Italo.txt` file from `FallCohort` to the `WinterCohort` folder
		mv italo.txt waitlist/
	
	- Oh no, our entire Winter Cohort had to be cancelled because of a worldwide pandemic :(   We decided to bump all of the scheduled winter students to spring. 
		In the `Bootcamp` directory create a copy of the `WinterCohort` folder called `SpringCohort`
		rm -r Bootcamp/fallcohort/waitlist
	
	- Please rename the WinterCohort folder to `WinterCohortCANCELLED`
		mv Bootcamp/WinterCohort Bootcamp/WinterCohortCANCELLED

	- Oh no! We're going out of business. Please delete the entire `Bootcamp` directory üò¢
		rm -r Bootcamp
-------------------------------------------------------------------------------------------------
-------------------------SHORTCUTS----------------------------------

General Terminal Shortcuts

____________________________________________________________________
| Shortcut     | Action                                            |
| ------------ | ------------------------------------------------- |
| **Ctrl + L** | Clear screen (same as `clear`)                    |
| **Ctrl + A** | Move cursor to start of line                      |
| **Ctrl + E** | Move cursor to end of line                        |
| **Ctrl + F** | Move cursor forword one step                      |
| **Ctrl + B** | Move cursor backword one step                     |
| **Ctrl + T** | Swap last two characters                          |
| **Alt  + T** | Swap last two words                               |
| **Ctrl + K** | Cut/delete everything from cursor to end          |
| **Ctrl + U** | Cut/delete everything from cursor to start        |
| **Ctrl + W** | Delete one word backwards                         |
| **Alt  + D*  | Delete one word forword                           |
| **Ctrl + H** | Delete one character backward                     |
| **Ctrl + Y** | Paste text removed by Ctrl + U/W/K                |
| **Ctrl + C** | Cancel/Stop current command                       |
| **Ctrl + Z** | Suspend/stop running process (send to background) | 
| **Ctrl + D** | Logout or exit terminal (similar to `exit`)       |
| **Tab**      | Auto-complete command / file / directory name     |
--------------------------------------------------------------------

Navigation Within Command Line
______________________________________________________________
| Shortcut               | Action                             |
| ---------------------- | ---------------------------------- |
| **Alt + B**            | Move cursor back one word          |
| **Alt + F**            | Move cursor forward one word       |
| **‚Üê / ‚Üí (Arrow keys)** | Move left/right                    |
| **Ctrl + P**           | Previous command (same as ‚Üë arrow) |
| **Ctrl + N**           | Next command (same as ‚Üì arrow)     |
|________________________|____________________________________|

Command Editing
____________________________________________________________
| Shortcut             | Action                            |
| -------------------- | --------------------------------- |
| **Up Arrow**         | Browse previous commands          |
| **Down Arrow**       | Browse next commands              |
| **Ctrl + Shift + C** | Copy text (in terminal emulator)  |
| **Ctrl + Shift + V** | Paste text (in terminal emulator) |
| **Ctrl + Shift + T** | Open new tab in terminal          |
| **Ctrl + Shift + N** | Open new terminal window          |
| **Ctrl + Shift + W** | Close current tab                 |
-------------------------------------------------------------

Process Management
_____________________________________________________________
| Shortcut     | Action                                     |
| ------------ | ------------------------------------------ |
| **Ctrl + C** | Kill/stop process                          |
| **Ctrl + Z** | Suspend process                            |
| **fg**       | Bring suspended process back to foreground |
| **bg**       | Run suspended job in background            |
| **jobs**     | Show background/suspended processes        |
-------------------------------------------------------------

History & Reuse
_________________________________________________________________
| Shortcut    | Action                                 			|
| ----------- | ------------------------------------------------|
| **history** | Show all previously used commands   			|
| **!!**      | Run last command again              			|
| **!n**      | Run command number `n` in history   			|
| **!ls**     | Run last command starting with `ls` 			|
| **Ctrl + R**| Search through command history (reverse search) |
| **Ctrl + G**| Exit history search mode                        |
-----------------------------------------------------------------

=============================================================================================
+++++++++++++++++++++             WORKING WITH FILES                    ++++++++++++++++++++
=============================================================================================

1. cat ‚Äî Concatenate and View File Contents
	Reads a file sequentially (line-by-line from start to end)
	Displays output to STDOUT (screen)
	Can create, append, or combine files
		example::
		--> cat filename.txt
	Create a new file
		cat > notes.txt
		# write content
		CTRL + D to save & exit
	Append to existing file
		cat >> notes.txt
				# Adds content without deleting old content
	Display with line numbers
		cat -n filename.txt
	Combine files
		Cat part1.txt part2.txt > final.txt
2. less ‚Äî Page Viewer for Large Files
	Loads files page-by-page instead of fully into memory
	Doesn‚Äôt modify file ‚Äî just for reading
	Faster for large logs (e.g., GB files)
	Example::
	--> less filename.txt
	navigation keys
	-------------------------------------
	| Key      | Action                 |
	| -------- | ---------------------- |
	| ‚Üë / ‚Üì    | Scroll line            |
	| Space    | Page down              |
	| b        | Page up                |
	| G        | End of file            |
	| g        | Start of file          |
	| /keyword | Search keyword forward |
	| ?keyword | Search backward        |
	| n / N    | next/previous search   |
	| q        | Quit                   |
    -------------------------------------
	Real use case:
		Read system logs in /var/log/
		Read config files (/etc/hosts)


3. tac ‚Äî Reverse Display of File

	Prints file from last line ‚Üí first line
	Useful when latest logs are at bottom
		example::
		--> tac logfile.txt
	Real use: debug apps by checking latest log entry first


4. rev ‚Äî Reverse Characters Per Line
    Reverses each line‚Äôs characters, not line order
	Example:
		echo "Linux" | rev
	Output:
		xuniL

	$ cat jkf.txt                        rev jkf.txt
	--> hello jk                          --> kj olleh
		no worry							  no wory
        this is part 2                        2 trap si siht

	
	Real use: formatting data received in reverse format (rare but helpful for challenges/ISO data)

5. head ‚Äî Show Top Lines of a File
	Shows first 10 lines by default
    Great for quick preview of content type
		Examples
		head file.txt
		head -n 20 file.txt   # first 20 lines  or head -20 file.txt
	Real use: preview CSV headers before processing

6. tail ‚Äî Show Bottom Lines of a File
    Shows last 10 lines by default
		Examlpe:
		--> tail file.txt
		--> tail -n 15 file.txt or tail -15 file.txt


7. wc ‚Äî Word, Line & Byte Count
	Option		Meaning
	-l			Number of lines
	-w			Number of words
	-c			Bytes used
	-m			Characters count
	Example
	--> wc sample.txt
	Output:
		12 45 280 sample.txt
		lines words bytes filename
	Real use cases:
    	Analytics on text files
    	Count user entries, error lines

8. sort ‚Äî Sorting Text Data
	Sorts text alphabetically or numerically
    Supports field-based sorting (important for CSV, logs)

	Basic sorting
		sort names.txt
üîπ Reverse sort
		sort -r names.txt
üîπ Sort unique items
		sort -u names.txt



Working With Files Exercise

Once you have downloaded the above zip file, unzip it! It contains two files: `poem.txt` and `purchases.txt`

## Part 1
	1.Use a command to print out the entire contents of the poem.txt file. Use an option so that the output also Icludes
		line numbers.
		--> cat -n poem.txt 

	2.That is a headache to read all at once! Read poem.txt using less instead. 
		Scroll down one line at a time
			--> less poem.txt 
				down arrow
		Scroll up one line at a time
			--> less poem.txt 
				up arrow	
		Scroll down one "page" at a time
			--> b
		Scroll up one "page" at a time
			--> G
	3. Search within less for the term "Dog".  Can you find the line that contains it? 
		--> less poem.txt
			/Dog enter
			-I enter
			=        # for line number
	4. Now it's time to do some research! Find the option to tell less to open with lines numbers displayed. Open 				poem.txt this way
		--> less -N poem.txt
	5. Then find the "command" you can type into less to go to exactly 50% of the way through the file.
		--> less poem.txt
			50%
    6. Use a command to find the number of words in poem.txt
		--> wc -w poem.txt
	7. Run a command to print out the first 4 lines of poem.txt
		--> head -4 poem.txt
	8. Run a command to print out the last 8 lines of poem.txt
		--> tail -8 poem.txt

	9. Run a command to print out the lines in purchases.txt in reverse order (last line printed first)
		--> tac purchases.txt
	10. Run a command to print out the lines in purchases.txt, sorted alphabetically.
		--> sort purchases.txt
	11. Run a command to count the number of lines in purchases.txt
		--> wc -l purchases.txt
	12. Run a command to print out the lines in purchases.txt, sorted by the price (the final column) in the dataset in 		REVERSE order (highest price to lowest price)
		--> sort -k3 purchases.txt -r

========================================================================================================================
üéØ STANDARD STREAMS IN LINUX

Whenever you run a command, Linux automatically opens 3 communication channels between the command and the terminal:

| Stream Name         | Abbreviation | File Descriptor | Purpose                                     |
| ------------------- | ------------ | --------------- | ------------------------------------------- |
| **Standard Input**  | `stdin`      | `0`             | What the command **reads**                  |
| **Standard Output** | `stdout`     | `1`             | What the command **prints** (normal output) |
| **Standard Error**  | `stderr`     | `2`             | Where error messages are printed            |



‚úÖ 1Ô∏è‚É£ Standard Input ‚Äî stdin (0)
The input you type into a program.
Example:
cat
Now type something ‚Üí it is being fed to stdin
Press CTRL + D to end.
‚úÖ 2Ô∏è‚É£ Standard Output ‚Äî stdout (1)
Normal command output goes to screen by default.
Example:
ls
The file list printed ‚Üí stdout
‚úÖ 3Ô∏è‚É£ Standard Error ‚Äî stderr (2)
Error messages also appear on screen, but they use a separate channel.
Example:
ls nofile
Output:
ls: cannot access 'nofile': No such file or directory
This error comes from stderr
üìå Why separate stdout and stderr?
So we can redirect:
    The correct output to a file ‚úÖ
    The errors somewhere else ‚úÖ
This gives more control and better scripting.
Example: extract only valid results from a command.



‚úÖ REDIRECTION OPERATORS

Redirection allows you to change the destination of a stream (instead of the terminal).

‚úÖ 1Ô∏è‚É£ Redirect Standard Output (stdout ‚Üí file)
 _____________________________________
| Command | Meaning                   |
| ------- | ------------------------- |
| `>`     | Write to file (overwrite) |
| `>>`    | Append to file            |
|_________|___________________________|

‚úÖ Example (overwrite)
ls > output.txt
üìå Creates/overwrites output.txt
Example (append)
ls >> output.txt
üìå Adds output to end of file
‚úÖ 2Ô∏è‚É£ Redirect Standard Error (stderr ‚Üí file)
ls nofile 2> error.txt
‚úî Errors go into error.txt
‚ùå Normal output still appears on terminal
‚úÖ 3Ô∏è‚É£ Redirect stdout AND stderr together
command > file 2>&1
OR simpler version:
command &> file
‚úî Both normal output & errors go into file
Example:
ls nofile /etc &> result.txt
‚úÖ 4Ô∏è‚É£ Redirect Standard Input (stdin)
command < file
Example:
cat < notes.txt
‚û° Same as: cat notes.txt
‚úÖ But important for some commands that require stdin

‚úÖ 5Ô∏è‚É£ Using pipes (|) ‚Äî Redirection to another command

command1 | command2

Output of first command ‚Üí input of second command

Example:

ls | grep "test"

‚úî Show only filenames containing ‚Äútest‚Äù
‚úÖ 6Ô∏è‚É£ Discard output using /dev/null

Throw result into trash (delete it)

ls nosuchfile 2>/dev/null

üìå Hides errors completely
‚úÖ Practical Examples to Understand Everything
üîπ Saving sorted list in a file

sort names.txt > sorted.txt

üîπ Save errors ONLY

grep "dog" animals.txt 2> errors.log

üîπ Save both errors & valid matches

grep "dog" animals.txt > result.txt 2> errors.txt

üîπ Save both into one file

grep "dog" animals.txt &> all.log

üîπ Count only valid entries, hide errors

grep "apple" *.txt 2>/dev/null | wc -l

====================================================================================
| Stream               | FD    | Default Direction         | Redirection           |
| -------------------- | ----- | ------------------------- | --------------------- |
| `stdin`              | 0     | Keyboard ‚Üí Program        | `<`                   |
| `stdout`             | 1     | Program ‚Üí Screen          | `>` or `>>`           |
| `stderr`             | 2     | Program ‚Üí Screen (errors) | `2>`                  |
| both stdout + stderr | 1 & 2 |                           | `&>` or `> file 2>&1` |
-----------------------------------------------------------------------------------
| Task                              | Command               |           |
| --------------------------------- | --------------------- | --------- |
| Send output to file               | `ls > file.txt`       |           |
| Append to file                    | `ls >> file.txt`      |           |
| Send errors to file               | `ls x 2>err.txt`      |           |
| Send both to file                 | `ls x &>all.txt`      |           |
| Pipe (redirect output to command) | `ls                   | grep txt` |
| Suppress errors                   | `command 2>/dev/null` |           |
=========================================================================

REDIRECTION EXERCISE
## Your Task

You are taking part in a wildlife survey in a remote portion of the Peruvian Amazon! This morning, three of your research assistants each went on transect walks where they recorded the individual species they observed.  
Your (simple) job is to combine their findings into a new file that contains all the species that were observed!

Create a new file called all-species.txt that contains the combined contents of angela-survey.txt, nico-survey.txt, and juan-survey.txt.  Do this using a single command!
	--> cat angela-survey.txt juan-survey.txt nico-survey.txt>> all-species.txt
The problem with the all-species.txt file is that it contains duplicate entries!  Use a single command to sort the lines in alphabetical order, only sorting uniques, and send the output to a new file called sorted-animals.txt
	--> sort -u all-species.txt > sorted-animals.txt
Now, you go out for a nice morning stroll and stumble upon a large anaconda sunning itself on a log.  You should add this observation to the list of species!!
	Start by appending the current date to the end of the sorted-animals.txt file using a command (don't open the file manually!)
		--> date >> sorted-animals.txt
	Then append the text "Green Anaconda" to the end of sorted-animals.txt
		--> echo "Green Anaconda" >> sorted-animals.txt
Run the non-existent command ughhh and redirect any error messages so that they are appended to the sorted-animals.txt file.
	--> ughhh 2>> sorted-animals.txt


====================================================================
PIPING IN LINUX
====================================================================

1. What is it?
----------------------------------------------------
Piping in Linux is a method to send the output of one command as the
input to another command. It allows chaining multiple commands together
without using temporary files.

Pipe symbol:
    |

General Syntax:
    command1 | command2

2. Why is it used?
----------------------------------------------------
- To filter and refine data step-by-step.
- To combine multiple commands into a single workflow.
- To process output dynamically without saving to files.
- To automate tasks efficiently in a command-line environment.
- To build complex data-processing pipelines.

3. How does it work?
----------------------------------------------------
Each command has standard streams: stdin (input) and stdout (output).
A pipe redirects stdout of one command directly into stdin of the next.

Conceptual flow:
    stdout of command1 --> stdin of command2

Multiple pipes can be chained:
    command1 | command2 | command3 | ...

4. Commands and Examples
----------------------------------------------------
Example 1:
    ls | grep ".txt"
Explanation:
    Displays only files containing the ".txt" extension.

Example 2:
    ls | grep ".txt" | wc -l
Explanation:
    Counts the number of .txt files in the current directory.

Example 3:
    cat /etc/passwd | cut -d ':' -f1
Explanation:
    Extracts only the username field from the system user list.

Example 4:
    ls -lh | sort -k5 -n | tail -5
Explanation:
    Shows the largest 5 files in the current directory by sorting on size.

Example 5:
    grep "ERROR" app.log | tail -10 | sort
Explanation:
    Filters error entries from a log, shows latest 10, and sorts them.

Example 6:
    echo "HELLO" | tr A-Z a-z
Explanation:
    Converts text to lowercase using a pipe.

5. Real-World Usage
----------------------------------------------------
- Log monitoring and filtering in DevOps
- Extracting specific columns from CSV/System files
- Sorting and counting results in analytics
- Searching through configuration or code files
- Automating tasks in scripts without temporary files

====================================================================
TR COMMAND IN LINUX
====================================================================

1. What is it?
----------------------------------------------------
The 'tr' command in Linux is used for translating, transforming, and
deleting characters from the input data. It modifies characters as per
the defined rules and outputs the result.

2. Why is it used?
----------------------------------------------------
- Convert uppercase to lowercase and vice-versa
- Remove unwanted characters from text
- Replace characters with another set of characters
- Compress repeated characters into a single occurrence
- Helpful in data cleaning and preprocessing

3. How does it work?
----------------------------------------------------
- Reads from standard input (stdin)
- Applies translation/transformation rules
- Outputs processed data to standard output (stdout)

General Syntax:
    tr [OPTION] SET1 [SET2]

4. Commands and Examples
----------------------------------------------------
Example 1: Convert lowercase to uppercase
    echo "linux" | tr a-z A-Z
Output:
    LINUX

Example 2: Convert uppercase to lowercase
    echo "HELLO" | tr A-Z a-z

Example 3: Replace spaces with underscores
    echo "Linux OS" | tr ' ' '_'
Output:
    Linux_OS

Example 4: Delete digits (-d)
    echo "abc123" | tr -d 0-9
Output:
    abc

Example 5: Squeeze repeated characters (-s)
    echo "aaabbccdd" | tr -s a-z
Output:
    abcd

Example 6: Remove vowels
    echo "hello world" | tr -d "aeiou"
Output:
    hll wrld

Example 7: remove alphabets
	echo "jaswanth.uppu@gmail.com" | tr -d [:alpha:]
Output:
	.@.
Example 8: remove blank spaces
	echo "uppu jaswanth kumar" | tr -d [:blank:]
Output:
	uppujaswanthkumar

5. Real-World Usage
----------------------------------------------------
- Converting case for usernames or data entries
- Formatting CSV/text before processing
- Removing special characters in logs
- Cleaning repeated whitespace
- Used frequently with pipes

====================================================================
TEE COMMAND IN LINUX
====================================================================

1. What is it?
----------------------------------------------------
The 'tee' command is used to read input from stdin, display the output
on the terminal, and write it to a file at the same time.

2. Why is it used?
----------------------------------------------------
- To save command output to a file *while still seeing it* on screen
- Useful in logging output of commands in pipelines
- Helps verify stored data immediately

3. How does it work?
----------------------------------------------------
Takes input ‚Üí Prints to terminal ‚Üí Writes to file

General Syntax:
    command | tee filename

4. Commands and Examples
----------------------------------------------------
Example 1: Display and save output
    ls | tee list.txt
Explanation:
    Shows output on screen AND saves to list.txt

Example 2: Append instead of overwrite (-a)
    ls | tee -a history.txt

Example 3: Multiple output files
    echo "Log Entry" | tee log1.txt log2.txt

Example 4: Logging commands with grep
    grep "error" app.log | tee errors.txt

Example 5: Combine wc and record keeping
    ls | wc -l | tee count.txt

5. Real-World Usage
----------------------------------------------------
- Storing important logs during monitoring
- Keeping record of script outputs
- Debugging by checking stored data immediately
- Useful in CI/CD pipelines (DevOps)


====================  PIPING EXERCISE  ======================
Unzip the file.  The resulting folder contains a subfolder called PokeDex/ which in turn contains a whole bunch of files, each named for a specific Pokemon like:
PokemonExercise/
	PokeDex/
		100Voltorb
		101Electrode
	  619Mienfoo
		...
Complete the following challenges using the starter files.  Make sure that you navigate to the PokemonExercise/ directory, but do NOT run any of the following commands from inside the PokeDex/ folder.  I repeat: any files that you create for the exercise should live inside of PokemonExercise/ NOT PokeDex/

Count the number of Pokemon files in the PokeDex/ folder.  You'll need to combine commands to make this work!
		--> ls -lh  PokeDex/ | wc -l

Next, create a new single file called all-pokemon.txt in the PokemonExercise folder (NOT the PokeDex folder)that contains the LOWERCASED name of every single Pokemon file in the directory, sorted in numerical order!  The end result should look like this: 
		--> ls PokeDex/|tr A-Z a-z|sort -n > all-pokeman.txt

Now that we have this file that includes all the Pokemon in numerical order, let's print out the three pigeon-related Pokemon: pidgey, pidgeotto, and pidgeot.  Using the command-line, print out lines 16-18.  It should look like this:
		--> head -18 all-pokeman.txt | tail -3

Next, up let's isolate the original 151 Pokemon.  Using a single pipeline...
	output the first 151 lines of the all-pokemon.txt file
	remove all digits 0-9 from the lines (using tr )
	sort the now number-less lines alphabetically
	store the new result in a file called original-151.txt in PokemonExercise
		--> head -150 all-pokeman.txt | tr -d 0-9 | sort > PokemonExercise

====================================================================
LINUX EXPANSIONS
====================================================================

1. What is it?
----------------------------------------------------
Expansion in Linux is the process where the shell (like Bash)
automatically replaces or expands certain symbols, patterns, or variables
before executing the command.

When you type a command, the shell first expands expressions
and then executes the final result.

Example:
    echo My home is $HOME
The shell expands $HOME to your actual home directory path.

2. Why is it used?
----------------------------------------------------
- To simplify commands and scripting.
- To dynamically substitute file names, variables, or patterns.
- To handle ranges, arithmetic, and substitutions easily.
- Reduces the need for manual typing and makes scripts more flexible.

3. How does it work?
----------------------------------------------------
Before executing any command, the shell scans the line for expandable
patterns such as $, ~, *, {}, [], and replaces them with corresponding
values or results.

The most common types of expansions are:
- Brace Expansion
- Tilde Expansion
- Variable Expansion
- Command Substitution
- Arithmetic Expansion
- Pathname Expansion
- Quote Removal (handled after expansions)

4. Commands and Examples
----------------------------------------------------
Example 1: Pathname Expansion (*, ?, [])
----------------------------------------------------
Used for filename pattern matching (globbing).

Command:
    ls *.txt
Explanation:
    Lists all files ending with .txt

Command:
    ls file?.txt
Explanation:
    Matches file1.txt, file2.txt but not file10.txt

Command:
    ls [abc]*
Explanation:
    Matches all files starting with a, b, or c.

Example 4:
    grep "[^0-9]" file.txt
Explanation:
    Matches lines that contain any character other than a digit.
	-->The caret at the beginning inside a character class means "NOT these characters".

----------------------------------------------------
Example 2: Tilde Expansion (~)
----------------------------------------------------
The tilde (~) expands to the current user‚Äôs home directory.

Command:
    echo ~
Output:
    /home/username

Command:
    cd ~
Explanation:
    Takes you to your home directory.
----------------------------------------------------
Example 3: Brace Expansion { }
----------------------------------------------------
Used to generate multiple text strings or sequences.

Syntax:
    echo {A,B,C}
Output:
    A B C

Example 2:
    echo file{1,2,3}.txt
Output:
    file1.txt file2.txt file3.txt

Example 3:
    mkdir project_{frontend,backend,design}
Explanation:
    Creates 3 directories:
    project_frontend, project_backend, project_design

Example 4:
    echo {1..5}  			#{start..end}
Output:
    1 2 3 4 5

Example 5:
	echo {0..100..5}       #{start..end..step}
Output:
	0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100
Example 6:
	echo {Z..A..2}
Output:
	Z X V T R P N L J H F D B
Example 7:
	echo {a,b{1..5},c,d}    #Nested Brace Expansion
Output: 
	a b1 b2 b3 b4 b5 c d


----------------------------------------------------
Example 4: Arithmetic Expansion $(( ))
----------------------------------------------------
Used to perform arithmetic calculations directly in shell.

Command:
    echo $((5 + 3))
Output:
    8

Command:
    a=10; b=4; 
	echo $((a * b))
Output:
    40

----------------------------------------------------
Example 5: Removing quotes (Quote Removal)
----------------------------------------------------
After expansion, the shell removes surrounding quotes if they were used
only for grouping and not escaping.

Command:
    echo "My home is $HOME"
Output:
    My home is /home/username
----------------------------------------------------
Example 6: Command Substitution $( )
----------------------------------------------------
Used to execute a command and use its output inside another command.

Command:
    echo "Today is $(date)"
Output:
    Today is Fri Nov 7 08:45:00 IST 2025

Command:
    files=$(ls)
    echo "My files are: $files"
----------------------------------------------------
Example 7: Variable Expansion ($VAR)
----------------------------------------------------
Variables in shell can be expanded using a dollar sign ($).

Command:
    name="Jaswanth"
    echo "Hello $name"
Output:
    Hello Jaswanth

Command:
    echo $HOME
Output:
    Expands to your home directory path.



----------------------------------------------------
Example 8: Parameter Expansion (Advanced Variable Forms)
----------------------------------------------------
Command:
    name="linux"
    echo ${name^^}
Output:
    LINUX
Explanation:
    Converts all letters to uppercase.

Command:
    echo ${name:0:3}
Output:
    lin
Explanation:
    Extracts first 3 characters of the variable.

Command:
    echo ${name/l/L}
Output:
    Linux
Explanation:
    Replaces first occurrence of 'l' with 'L'.


----------------------------------------------------
Example 12: Combining Expansions
----------------------------------------------------
Command:
    echo "Total files: $(ls | wc -l), Today: $(date +%A)"
Output:
    Total files: 15, Today: Friday

5. Real-World Usage
----------------------------------------------------
- Generating multiple files or folders with brace expansion.
- Using variable and command substitution in shell scripts.
- Performing quick arithmetic in scripts or terminals.
- Pattern-based filename matching for automation.
- Embedding command outputs into dynamic strings.

6. Summary
----------------------------------------------------
- Expansions are automatic replacements done by the shell.
- Common types:
    1. Brace Expansion: {1..5}, {a,b,c}
    2. Tilde Expansion: ~ ‚Üí /home/user
    3. Variable Expansion: $VAR
    4. Command Substitution: $(command)
    5. Arithmetic Expansion: $((expression))
    6. Pathname Expansion: *, ?, []
- Greatly improves command efficiency and scripting flexibility.



touch {morning,afternoon}-day-{1..30}

touch todos-$(date +"%m-%d-%y").txt

ls *9

ls *1?

ls afternoon*7

mkdir Mornings
mv morning* Mornings

mkdir -p Year/{Winter/{Yard,House},Spring/{Yard,House},Summer/{Yard,House},Fall/{Yard,House}}

touch Year/{Winter/{Yard,House},Spring/{Yard,House},Summer/{Yard,House},Fall/{Yard,House}}/{todos,done}.txt 
























